# 微服务简介(MicroService)

微服务是一种架构风格，一个或多个小的微服务组成一个复杂、庞大的软件应用。每个微服务集中在完成一个较小业务能力的任务。这些微服务可以用任意语言开发。

Martin Fowler’s 定义的微服务，微服务用于组成复杂的应用，微服务够小，独立、进程可替代、微服务之间使用轻量级的API， 并且微服务不依赖统一的开发语言

更多信息参考：Martin Fowler的论文“Microservices: A new architectural term”, http://martinfowler.com/articles/microservices.html


## 微服务多小才算小

微服务大小不是由代码行数决定的，微服务足够小，聚焦在特定目的。微服务应用做一件事情，并且做好这件事情。

## 独立和自治（independence and autonomy）

为了确保每个服务在创建、维护时保持敏捷性，每个服务应该独立和自治。每个服务能够在任何时间启动、停止、替换，不会紧密与其他服务绑定。微服务其他要素遵循这一点。

微服务架构风格应该扮演一个包装来守护应用的具体实现细节。这种配置允许服务的实现，以后可被修订并且提升（甚至重写）。特别是数据源必须是服务私有的。

## 弹性和容错（resilience and fault tolerance）

服务需要具有弹性的能力，也就是说在动态的云环境中，服务需要预测和平缓地响应异常，即当服务接收到错误的数据时，不会影响到后台服务（Backing Service），或者处理分布式系统中并发更新的冲突。

独立演进但是相互之间存在依赖关系的服务，鲁棒性原则提供最佳指导：“对接收的可以进行自由操作，对于发出的需要谨慎处理”。  假设API会逐渐演进，对于无法理解的数据能够容错，引用RFC：
    简单举例，一个协议包含多个枚举值，这些枚举类一定是不完整的。因此，如果协议定义了4个可能的错误码，当服务接收到第5个错误码时，服务不会宕机。无法识别的编码可能会记录到日志中，但是不会引起错误。

微服务必须避免错误在系统之间进行层级传递。需要设计某种策略处理API的变更引起的变化。分离模式，例如熔断和隔板。


## 自动化的环境（automated environment）

云环境中的微服务架构，创建一个不规则延伸的独立迁移个体。服务之间的交互关系错综复杂。一个高度自动化的应用对于微服务来说至关重要。

微服务通常需要设计一种策略来进行代码构建和部署，例如持续集成和持续部署。

自动化监控和告警也很重要，虽然独立的服务应该尽可能少的考虑如何管理自己的日志数据，但是他们应该确保合适的日志数据和指标数据能促进自动化的问题检测和告警。


## 微服务和团队结构

微服务架构和团队组织之间的关系具有一定哲理性。微服务的结构要与人员组织结构一致。根据康威定律（Conway's law），任何组织所设计的系统，将不可避免的与组织结构一致。
# 1 创建微服务

## 1.1 定义服务

### 采用领域驱动设计原则

在领域驱动设计中，一个domain表示一个特定的知识领域或活动。一个model代表领域某个重要方面的抽象，用于理解领域的变化。这个模型用于构建解决方案，跨团队交流。

Bounded Context允许领域被分为多个独立的子系统。每个Bounded Context可以拥有自己的模型来表示Domain中的概念。

### 将领域元素转换为服务

### 应用和服务结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181243437.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单体架构，通常将应用分为客户端、Web、业务层、数据层，微服务架构也采用类似的方式进行划分，但是每层的元素由独立的服务提供，并且运行在独立的进程中，如上图2所示。

- BFF（backend for frontend）用于支持特定的前端特定的行为，例如优化设备或提供Web应用额外的能力
- 每个服务拥有和维护各自的数据存储层，数据存储也是独立的服务

然而，不是所有的微服务应用都需要BFF层，例如使用JSP或JSF等与前端Javascript相关的应用，可以看做是BFF层。而单页面应用，是一些静态资源，来自独立的服务，它们运行在浏览器中，直接调用后台API，这种方式是不需要BFF的。


**微服务内部结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181152474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

微服务架构中每个服务的内部情况，如上图所示。调用外部服务应该与领域逻辑进行分离，也应该与后台数据服务进行分离。

图中包括以下几个元素：
- Resources 向外部客户端提供资源，这层对请求进行基本的验证，然后将信息传递到Domain逻辑层
- Domain logic，领域逻辑层，一般有很多形式。在Boundary-Entity-Control模式中，领域逻辑表示entity，参数校验，状态变化逻辑等
- Repository （可选），用于提供核心Domain Logic与数据存储之间的抽象。这个配置允许后台数据存储层的改变或替换不会影响Domain Logic层
-Service connectors 类似于Repository 抽象，封装了与其他服务之间的通讯。这层的功能是作为门面，保护Domain logic不会受外部资源API改变而产生影响。也提供API 格式向内部Domain model结构转换功能。

这个架构要求我们在创建类Classes时，需要遵守一些规则，例如每个用于实现服务的class需要执行至少一项任务：
1.执行Domain Logic
2.显示Resources
3.调用其他服务
4.调用数据存储层

一般而言，建议代码结构不需要严格按照上述进行创建。最重要的是，减少变化带来的风险。例如，如果我们需要改变数据存储（data store），我们可能需要更新Repository层。我们不需要搜索所有的类，来找到那些方法调用了数据存储层。如果外部API服务发生变化，我们可以通过改变service connector中来进行调整。




### 共享库或新建服务

根据DRY（Don't repeat yourself）原则，重复的代码最好封装成公共的方法或库。在微服务架构中，由于服务是相互隔离的进程，这使得获取共享代码实现变得很困难，因而，如何处理共用的代码呢？

1. 接受微服务架构中存在冗余的代码
2. 将共用代码封装成共享的、版本控制的代码库
3. 新建独立的服务

根据代码的本质，最好接受冗余的代码，因为，这样可以保持每个服务的独立演进，便于后续服务的更新这部分初始化共用的代码。

虽然将Data Transfer Objects创建为共享的库比较方便，并且这些DTO也是简单的类，通常用于生成JSON格式，但是这样会丢失对DTO实现细节，并且会增加耦合性。

客户端库最好避免代码冗余，最好让客户端库容易消费APIs。这个技术在数据存储中使用比较常见，包括NoSQL数据存储，提供基于REST的APIs。客户端库同样能为其他服务使用，特别是一些使用二进制的协议。然而，客户端库会引入服务消费与提供者的耦合性。这个服务可能会很难被平台消费，或者很难被没有库支持的语言消费。

共享库也可以用于确保复杂算法过程的一致性，

什么时候讲共享库创建为独立的服务呢？一个独立的服务，可以使用独立的语言开发，可以进行分离的扩展，可以快速的更新服务而不需要同步更新消费者。一个独立的服务也可以添加扩展的进程，从属于服务之间交流。

## 1.2 创建RESTAPIs

如何设计微服务的API呢? 在微服务架构中设计有效和可用的API至关重要，API需要提供文档说明，版本控制，便于消费者理解和使用这些API。

### 从上到下或从下到上

API的设计有两种思路，一种是先设计API然后开展代码实现，一种是先实现服务然后提取API。原则上，第一种方式较好。微服务不是独立进行操作的，服务可能调用其他的服务也可能被其他服务调用。服务之间的调用需要提交定义清除，并且形成文档。


### API 文档

使用工具生成APIs说明文档，规范的API文档有利于精确和正确的使用这些API，也可以用于和API消费者讨论API。这些文档也可以用于消费者驱动的测试。

[Open API Initiative](https://www.openapis.org/) （OAI）是一个标准化RESTful APIs描述的组织。OpenAPI 说明是基于Swagger的，它定义了表示RESTful API结构和元数据格式的创建方法。这中定义由一个可移动的文件描述（swagger.json，也有swagger.yml）。可以使用可视化编辑器或注解的方式在应用中定义swagger。在后续开发中，可以用于生成客户端和server stubs。



### 使用正确的HTTP动词

REST APIs应该使用标准的HTTP方法来表示创建、查询、更新、删除和操作，以及幂等操作。

- POST   表示资源的创建，POST不是幂等操作。例如，多次发起POST请求，每个请求会生成唯一的资源
- GET     表示查询资源，是幂等性操作，多次请求不会产生副作用。GET请求的查询参数不应该用于改变或更新信息。
- PUT     表示更新资源，PUT操作是幂等性的，PUT 操作的请求体，通常包含整个需要更新的资源信息。
- PATCH 表示更新部分资源，根据业务情况可以是幂等操作也可以不是。例如，如果一个PATCH操作，表示一个数值需要从A变到B，这种是幂等操作。多次请求也不会产生其他影响，当数值已经改成B了。
- DELETE 表示删除资源，删除操作是幂等性的，资源只能删除一次。第一次调用时。响应码为200表示操作成功，后续再调用时，响应码为204表示资源未找到。

### 创建机器友好、可描述的结果

一个具有表现力的REST API应用谨慎的考虑返回的结果。由于API的调用一般是使用软件而不是用户，因此，需要与注意调用者的交流尽可能的有效和高效。

例如，比较常见的实践，当我们使用200返回码来HTML解释错误信息。虽然，技术上没有什么问题，用户可以看到错误的页面信息，但是对于机器来说，会认为这次请求成功了。

HTTP状态码应该是有用的并且有相关性的。当操作正常时使用200（OK）。当没有内容返回时，使用204（NO CONTENT）。201（CREATED）应该用于POST请求，表明创建资源的结果，无论是否有响应体。当并发更新冲突时使用409（CONFLICT），当请求参数类型不正确时使用400（BAD REQUEST）。

### 资源URI和版本

RESTful 资源 URI有很多可选的地方。一般而言，资源应该以名词进行描述，而不是动词，节点应该以复数的形式表示。例如：


| URI  | 说明  |
| --- | --- |
| POST /accounts | Create a new item |
| GET /accounts   | Retrieve a list of items |
| GET /accounts/16 | Retrieve a specific item |
| PUT /accounts/16 | Update a specific item |
| PATCH /accounts/16 | Update a specific item |
| DELETE /accounts/16 | Delete a specific item |

URI可以是层级嵌套的方式组织

**版本控制**

微服务最大的好处是，每个服务都可以独立开发演进。服务之间的调用保持独立的前提是，这些API不能轻易更改。

稳健性原则，服务作为发送方要保守一些，作为接收方可以随意一些，在API改变之前一直要保持这种原则。当仍然需要修改API时，可以选择构建一个不同的整个服务，并逐渐替换原始的服务，也许领域模型的演进和更好的抽象能让这件事情更有意义。

如果不需要改变现有的API服务，那么如何管理这些改变呢：
- 服务是否处理所有版本的API？
- 是否需要维护服务的版本来支持多个版本的API？
- 服务是否只支持最新版的API，并且依赖其他的适配层来转换和来自旧版的API？

我们很难抉择，最本质的问题是，我们如何映射API的版本。这有三种方式来处理REST资源的版本：
- 在URI中设置版本
- 使用自定义的版本请求头
- 将版本设置在HTTP的Accept请求头，并依赖内容协调

**URI中添加版本信息** 
这种是最简单的方法来指定版本，有以下几个优点：
- 容易理解
- 容易实现
- 容易使用API浏览工具（例如 Swagger） 和 命令行工具（例如 curl）

如果决定采用URI中版本进行控制，那么版本号需要设置到整个应用上，例如 `api/v1/accounts` ，而不是`api/accounts/v1` .

如果决定使用URI中版本，我们可以采用不同的方式进行管理，部分取决于请求在系统中如何路由。

当然也有反对这种版本控制方式，URL是HTML标准中一个严格解释的，一条URL应该代表一个实体并且如果实体不改变，那么URL也不改变。

其他也指出，将版本放到URI中需要消费者更新他们的URI引用。这种问题可以通过将旧版URI映射到新的请求中，然而，当最新的版本改变时，这样的方法会出现异常行为。

**添加自定义的请求头**

我们也可以添加自定义的请求头来指明API的版本。自定义的请求头可以被路由器或其他基础设施来路由到特定的后台实例。然而，这种机制不容易使用。此外，这种自定义的头只能在我们自己的应用中使用，也就是消费者需要学习如何使用。

**修改Accept Header添加版本**

Accept Header是一个比较明显的地方用于定义版本，但是很难测试。URIs 很容易指定并替换，但是指定HTTPHeader需要更多API的信息以及命令行调用。

设计API时，有以下几点建议：
1.从消费者的角度设计APIs
2.考虑API改变的策略
3.在整个应用中使用一致的版本控制技术

# 3 服务注册与发现

微服务被设计成能够容易水平扩展，需要一种方法来解决多个服务实例如何定位，并且对多个服务的调用如何负载均衡。服务定位包括以下三个部分内容：
1.服务注册
2.服务调用
3.API网关

## 服务注册

服务注册是一个持久化的存储，用于记录当前可用的微服务列表，以及访问他们的路由信息。微服务之间通信需要注册服务，主要因为以下几个原因：
1.注册
当一个服务成功的部署后，微服务需要通过服务注册进行注册
2.心跳
微服务应该发送规律的心跳信息，到注册中心，用于表明当前微服务是正常工作，可以接受请求。
3.服务发现
为了调用其他服务，微服务需要调用注册中心获取可用的服务实例
4.注销
当一个服务关闭后，需要从注册列表中移除该服务。

### 第三方注册 VS 自注册

注册微服务可以在服务中实现也可以使用第三方注册服务。使用第三方注册服务，要求微服务准确测定当前状态并将信息传给注册服务。第三方注册服务也可以注销微服务。如果微服务自己执行注册和心跳检测，注册服务可以取消注册，如果发现心跳丢失。

使用第三方注册服务的优势是，可以将注册和心跳检测的逻辑与业务逻辑分离。缺点是软件需要部署额外的部分，微服务也需要提供健康端点给第三方注册服务使用。

自注册（self-registration）将注册和心跳检测逻辑写入到微服务自身中，这种方式需要小心处理代码测试。然而，很多服务注册解决方案提供一种方便的库用于服务注册，来降低编码的复杂度。

服务发现与注册方案

Consul

Eureka

这些都是开源的服务注册工具，Eureka是Netfli公司的技术，能很容易和其他解决方案进行集成，并且提供负载均衡和容错。


### 可用性 vs 一致性

大部分服务注册中心提供分区容忍，一致性或可用性。他们不可能同时满足CAP理论中三个条件。Eureka提供可用性，Consul和Apache Zookeeper提供一致性。如果我们应用需要在某一个能看到相同的视图，那么选用一致性的服务注册方案；如果需要很快的获得请求的答复，而不需要等待结果的一致性，可以选用可用性的方案。

## 服务调用

当服务需要与其他服务进行通信时，它需要使用存储到服务注册中心的信息。然后，通过服务端或客户端调用实际的微服务。

### 服务端

通过服务代理实现服务端通信，Service Proxy作为服务注册中心的一部分，或者独立的服务。当服务需要调用其他服务时，首先调用代理服务端点。这个代理服务会返回从服务注册中心获取的目标服务的地址。代理器将获取的结果和路由返回给原服务，提供给原服务用于发起请求。负载均衡完全在服务端处理。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180516410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

使用Server-side调用有以下几个优势：
1.请求简单
请求会很简单，因为微服务调用一个已知的终端。
2.容易测试
使用服务代理将负载均衡或路由逻辑从微服务中剥离，这样可以使用Mocked代理测试服务的所有功能。

然而，这种方式也存在缺陷

1.路由跳转过多
新增的服务代理，增加了网络请求的次数。这方式比客户端方案需要调用的次数更多。而用代理服务次缓存请求是没有价值的，很多情景，请求会走1->4->5->6

### 客户端（Client side）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180538417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)


微服务之间的调用也可以直接使用客户端调用。服务注册返回微服务一个或多个实例的地址；然后，由客户端向该地址发出请求。微服务的地址通常会被缓存起来，这样在后续的调用中可以直接访问实际的地址，而不需要向注册服务查询。如果直接访问实际地址失败，客户端将重复第一次操作，向注册服务获取信息。最好对服务地址的缓存设置超时，这样当新版的服务部署后，其他服务不会访问缓存中错误的地址，而访问新的实例。

发起这些请求，以及负载均衡可以使用以下两种方式实现：
1.客户端库（Client library）
2.边车（sidecar）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180550360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

两种方式都可以在客户端发起请求。然而，客户端库与微服务是一个整体，一起运行的；而边车（sidecar）是与微服务部署在一起的，可以运行在独立的进程。

**client library**
客户端库的方式很有效，将与其他远程资源通信的逻辑独立开。对于服务注册中心，client libraris可以是 Consul 或 Netflix Eureka 用于处理服务注册和心跳检测。其他的库，例如Netflix Ribbon，提供客户端的负载均衡。

一般而言，选用一个现有的库而不是自己写。如果所有的微服务使用Java编写，那边我们需要标准化这个库。如果我们有一个微服务系统，最好每个微服务使用相同的库进行请求调用，这样开发者从一个服务向另一个服务过渡不会增加基础设施和构建进程的复杂性。

这种方式的弊端是，我们将复杂的服务调用融入到了服务中，这样测试服务会变得很复杂，需要很好的区分使用了client library的代码和业务逻辑代码。

**sidecar**
另个比较好的方案是使用边车模式，边车是一个与微服务部署在一起的分离进程，或者一个分离的容器进程，或相关联的分离的容器。

边车调用服务注册中心获取服务注册信息，并保存这些信息，也具有客户端的负载均衡能力，来调用其他服务。

由于边车运行在自己的进程中，他可以使用独立的语言开发。在所有微服务中可以使用相同边车实现，而不需要管微服务使用何种语言。

[Netflix Prana](http://github.com/Netflix/Prana)是一个开源的边车组件用于提供Ribbon和Eureka客户端的能力。

[Kubernates](http://kubernetes.io/docs/user-guide/services)是一个容器编排引擎，提供服务发现和负载均衡能力的sidecar。


## API网关

API 网关（API Gateway）能够执行内部或外部客户端的服务的调用。API Gateway与服务代理的角色很像。服务向API网关发送请求，而服务网关向服务注册中心获取服务地址，然后根据地址发起请求，将请求后的结果返回给调用者。与代理服务器不同的是，API网关可以提供不同与原微服务提供的API。

内部的微服务可以使用确切的APIs，同时API网关提供外部客户端调用。一般来说，微服务提供细粒度的APIs，而外部客户端通常不需要那么细粒度的API，这时API网关可以屏蔽内部一些API，向外部客户端提供有用的API。所有的外部客户端通过API网关访问应用。

# 4 微服务间通信

在分布式系统中，服务内部的通信很重要的。组成应用的微服务需要一起无缝的工作，向客户端提供服务。不同服务之间的通信有两种形式，同步和异步调用。

## 4.1 同步和异步

同步通信，即请求后立马获得响应。异步通信，是一种消息，不需要响应。

高度分布式系统中使用异步事件或消息就是强有力的应用场景。

对于任何一种调用风格，开放的API需要提供文档说明。事件或消息负载也需要提供文档说明。事件订阅者或API消费者应该容忍不识别的字段，它们可能是新的。服务应该抛出异常和处理错误数据。

### 同步信息（REST）

在分布式系统中，异步形式的消息是很有价值的。当应用清晰的请求和响应语义，或一个服务需要与另一个服务紧密关联行为，应该使用异步API。

很多RESTful 操作能解析JSON格式的数据，当让其他协议或格式的数据也可以。基于Java的微服务最好使用JSON数据格式。



### 异步信息（Event）

异步消息能够解耦服务。一个异步事件能够使用，如果事件创造者不需要响应信息。

一个来自外部客户端的请求在获取响应信息前可能会穿过多个微服务。如果每个调用都是同步的，那么整个时间会阻断其他请求。微服务系统越复杂，那么微服务之间的交互需要额外的请求，将导致系统延时更长。如果请求的进程可以被异步事件替代，那么可以用事件来取代。

使用响应式的事件，一个服务应该发布自己状态或活动的事件。其他服务可以订阅这些事件并协同响应。

事件是很好的方式组建新的交互模式，而不需要引入依赖。这种使得框架具有扩展性，不需要再服务创建的时候考虑，后续可以扩展。

微服务风格的架构需要每个微服务拥有自己的数据。这意味着当请求进来时，可能有好几个服务需要更新自己的数据库。服务应该使用事件来通知数据变化，其他模块可以订阅这些事件。

为了协调应用中的消息，我们可以使用任何一个可用的消息代理方案。例如AMQP、RabbitMQ、Apache Kafka， MQTT等。

## 4.2 容错

我们选用微服务架构，一个很重要的动机是微服务架构可以创建容错和弹性伸缩的应用。现代应用被要求具有接近零的停机时间，秒级以内的响应。微服务架构中每个独立的服务必须能持续工作，即便其他的服务已经宕机。这就要就微服务应用在设计时具有容错的能力。

### 弹性可变

当使用同步请求调用其他微服务时，我们使用的是具体API，API被事先定义了输入属性，以及输出属性。微服务环境中，这种API的请求和响应数据一般采用JSON格式。现实中，我们很难保证输入和输出的属性不发生更改。基本是最佳的应用设计实践，需求也是经常改变的，这会造成属性的增加、删除或改变。为了弹性的应对这些变化，微服务的设计者需要考虑到API的消费和生成。

**APIs 消费**
作为API的消费者，我们需要校验调用API后获取的响应数据，判断它是否包含我们功能执行所需的信息。如果获取JSON格式的数据，我们需要解析JSON数据，在执行其他转换之前。当我们校验JSON或解析JSON时，我们必须做两件事情：

1.只校验请求中需要使用的变量或熟悉
不需要校验请求提供的所有变量。如果我们使用这些请求中的参数，我们不需要它们。
2.接受未知的属性
不需要提交异常，如果我们接收到异常的变量。如果响应体共包含我们所需的信息，那么不用在意其他额外的属性。

选择JSON解析工具允许我们配置如何解析进来的数据。例如Jackson提供@JsonInclude和@JsonIgnoreProperties注解的方式解析数据。

遵从这两天规则，我们的微服务可以变得更加弹性来应对任何改变，而不会受到直接影响。基本微服务添加或移除我们并未使用的属性，微服务仍然正常工作。

**APIs 生成**

当提供外部客户端调用的API时，请求和响应中有两件事需要考虑：
1.接收未知的请求属性
如果一个服务调用API，请求中包括不需要的参数，那么服务可以丢弃这些参数值。只有引起不需要的失败时才返回错误信息。
2.只返回API调用相关的属性
留尽可能多的空间来实现服务后续的改变。避免分享的过程中泄露实现细节。

遵从这两条可以让服务更加稳健。


### 超时（Timeouts）

当请求其他微服务时，无论同步请求或异步请求，请求必须设置超时参数。因为，我们希望用完服务就走，而不应该等待不确定的响应。

异步请求可以设置超时参数，例如 Failsafe和 Netflix Hystrix内置了超时设置。

设置超时可以提升微服务的弹性，但是仍然会导致不好的用户体验，因为端到端的调用会变慢。如果可以的话将超时设置一致，那么服务A向服务B请求超时，同时服务B等待服务C。

### 熔断（Circuit Breakers）

使用超时保护请求，避免等待不确定的响应。然而，如果某个请求经常发生超时，这会浪费很多时间等待超时发生。

熔断（Circuit Breaker）是一种用来避免重复超时发生的技术。这种技术类似电路里面的保险丝。熔断会记录每个调用失败或超时的请求。如果这些请求次数总和达到了一定的阈值，它会阻断后续请求的调用，直接返回错误信息。它也提供一种机制来重新尝试请求，尝试几次或根据响应某个事件。

熔断对于调用外界服务至关重要，一般来说，使用现在的熔断库即可实现此功能。

### 隔板（Bulkheads）

在轮船中，隔板用来隔离船舱避免因一个船舱漏水造成整个船沉掉。微服务中的隔板（Bulkheads）类似轮船中的隔板概念。我们需要避免微服务中某个部分的失败不会对整个微服务系统造成影响。隔板模式就是关于如何创建微服务而不是使用某个特定工具或库。当我们创建微服务时，我们总是告诫自己如何分离不同的模块，并且避免滚雪球式的崩溃。

实现隔板模式最简单的方式是提供回退（fallbacks）。添加fallback运行应用继续工作，当非重重要的服务宕机时。例如，一个在线的零售店系统，其中一个服务提供用户推荐信息，如果推荐服务宕机了，那么用户仍然可以查询商品和下单。一个有趣的回退链例子，当调用个性内容失败时，回退成调用更加一般的内容，这将回退成返回缓存内容，而不是返回错误。

另一种策略，为了避免慢的或勉强的远程资源造成整个系统宕机，可以使用受限可用的资源来应对这些超出的请求，最常见的方式使用队列（queue），以及 [信号量（semaphore）](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html) 

**队列**
队列有一个大小设置，当请求添加到已满的队列时，该请求会直接抛错。队列会生成有限数量的worker，每个定义了服务最大的线程数，可以被远程资源阻塞。

**信号量（semaphore）**
semaphore机制工作原理，是提供多个permits，向远端发起请求是需要一个permit，当请求完成后会释放permit。

队列和信号量最显著的区别是在资源用尽时的处理不同，使用Semaphore方法，超出的请求会直接被跳过，如果不能获取到permit； 而队列的方式，请求会等待（除非队列满了，请求会被丢弃）。



# 5 数据处理


## 5.1 微服务中数据特征

定义微服务中的存储数据有一种方法，即从上到下方法。有业务级开始设计数据模型。如何定义数据、如何处理数据、如何与其他微服务的数据存储进行共享。

### 领域驱动设计实体

根据领域驱动设计，我们将会有以下几类对象：
1. 实体 Entity
    一个不是由它的属性进行定义的对象，而是根据线程定义的。
2. Value Object
    一个对象包含属性，但是没有概念的定义，可以被认为是不可变的。
3. 集合 Aggregate
    一个对象的集合，由一个根entity所组织，根节点确保变化的 一致性，避免外部对象需要引用其成员。
4. 仓库 Repository
    检索领域对象的方法应该委托给Repository对象，这样便于更换具体的存储实现的方法。


这些对象映射到我们的持久存储。领域模型（domain model）是逻辑数据模型和物理数据模型的基础。

参考：http://dddcommunity.org/resources/ddd_terms/

### 分离每个微服务的数据存储

每个微服务应该有自己的数据存储，这样可以与其他服务进行解耦，如下图所示。第二个服务不能直接访问第一个服务的存储层。

这样设计有以下几个理由：
1. 如果两个微服务共享数据存储，他们将紧密耦合。改变一个微服务的数据结构，例如table，可能影响另一个微服务。如果微服务这种方式耦合，那么部署新版需要花费时间进行协调，而这是可以避免的。
2.每个微服务应该使用最有利该服务功能的数据类型。我们不需要权衡不同服务如何选择数据库系统。每个微服务使用最合适的数据库。
3.从性能的角度考虑，每个微服务拥有自己的数据存储，这样扩展就会很容易。数据存储可以拥有自己的服务器。

对于关系型数据库的数据存储分离可以采用以下几种方式：
1.每个微服务一个Schema
    每个微服务拥有自己的schema。其他微服务可以使用相同的数据库，但是使用不同的schema。可以通过数据库访问控制机制进行约束，避免开发者直接访问其他schema。
2.每个微服务一个Database
    每个微服务可以拥有自己的数据库，但是与其他微服务共享数据库服务器。不同的数据库，用户可以连接到各自的数据库，这是一种很好的分离方式。
3.每个微服务一个数据库服务器
    最高度的分离，即每个微服务拥有独自的数据库服务器。当需要更高的性能时，可以采用这种方式。
    
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214609705.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)
### 混合持久化（Polyglot Persistence）

每个微服务应该有自己的数据存储，这意味着可以使用不同的数据存储技术。NoSQL运动导致很多新的数据存储技术产生，NoSQL可以和传统关系型数据库一起使用。根据应用需求，可以选用不同的数据存储类型来实现。在一个应用中使用多种数据存储技术，称为混合持久化。
 
对于某些微服务，最好用关系型数据库存储数据。其他服务，如果使用到不同的数据类型（非结构、复杂、有向图）等数据可以存储在NoSQL数据库。


https://martinfowler.com/bliki/PolyglotPersistence.html

### 跨微服务数据共享

某些情景下，一个微服务的客户端可能请求另一个微服务的数据。例如，一个客户端可能需要查看他的账单和以及账单状态。然后，他可能需要查询他的账户，然后到账单服务。微服务最佳实践避免将数据存在同一个数据库中。为了解决上述这个业务场景，我们可以实现一个适配服务，用于查询Account服务和Payment服务，然后将查询结果发给客户端。适配器服务也负责处理接收数据的转换，如果有需要的话。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214637724.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

改变数据会变得很复杂。在一个微服务系统中，某些业务事务横跨多个微服务。在一个零售店应用的微服务示例中，可能有一个服务用于下单，一个服务由于付款。因此，如果一个消费者用户想购买商店的某个东西时，这个业务事务可能在这两个服务中扭转。每个微服务有自己的数据存储，因此业务事务可能横跨两个或多个微服务，将调用多个数据存储。如何应对这种业务事务呢？


**Event-Driven 架构**

在调用涉及多个微服务的业务事务时，我们需要确保数据的一致性。可以采用分布式事务，但是有很多理由表明不应该在微服务应用中使用。主要的原因是会让微服务变得过于耦合。如果两个微服务在一个分布式事务中调用，那么其中一个错处或有性能问题，那么另一个服务也会等待直到超时发生，回滚事务。

使用事件驱动架构（Event-Driven architecture）是最好的方式来解决横跨多个微服务的业务事务。为了改变数据，第一个服务更新数据，在同一个事务中，发布一个事件。第二个微服务，订阅这个事件，当接收到这个事件时，也改变自己的数据。使用发布/订阅（publish/subscribe）通信模型，可以让两个微服务松耦合。这个耦合只存在于交互的消息中。这个技术使得微服务系统可以维护多个微服务的数据一致性，而不需要使用分布式事务。

如果微服务应用中，微服务之间发送很多消息，最好可以将这些服务合并成一个服务。但是这样可能会违背领域驱动设计的原则。横跨多个微服务的适配服务负责复杂的数据更新，可以采用事件的方式实现。

**最终一致性 （Eventual Consistency）**

在事件驱动的架构中，发送消息可能产生最终一致性的问题。这是君臣发生的运行时问题：服务A改变自己的数据，并发送消息到服务B，经过很短的一段时间后，服务B接收到消息，并改变自己的数据。在这个很短的接收时间里，两个服务的数据是不一致的。例如，服务A更新了订单数据，并发送消息到付款服务B，直到服务B处理完付款，有一个订单已经被付款了。当消息的接收者不能处理这个消息时会发生错误。在这个情况下，消息系统或接收消息的微服务需要解决这个问题。

由于微服务框架中每个服务拥有自己的数据库，横跨多个服务的业务事务会引入最终一致的问题。如下图所示的，可以解决这个问题。订单服务保存订单，发送操作事件。例如 OrderCreated事件 发送到Payment服务，当订单服务没有接收到Payment服务的确认消息前，订单服务处于等待状态。

付款服务（Payment）订阅OrderCreated事件，接收后处理这个事件，并在数据存储中处理付款。如果付款成功，那么将发布PaymentApproval事件，这个事件被订单服务（Order）订阅。当处理完PaymentApproval事件后，订单的状态会从等待变为批准。如果消费者查询订单的状态，他将获得两种状态中的一种：订单等待或订单完成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214715470.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

在这种情境下，当数据不可用时，服务可以发送“对不起，请稍后重试”的消息到客户端。

**数据备份**

数据库系统的数据备份机制可以解决，因数据存储分离造成的数据获取问题。使用数据备份，例如，使用数据库触发器或时序的存储过程或其他进程，多个服务之间共享数据同样存在缺陷。改变一方的数据结构，将会导致备份进程的问题。这个备份机制必须能适应后续新增的服务部署。这也是一种紧耦合的形式，需要避免。

综上所述，事件驱动可以解耦两个数据存储。服务可以处理自己数据中这些事件有关的数据转换。



### Event Sourcing 和CQRS（Command Query Responsibility Segregation）

在事件驱动架构中，Command Query Responsibility Segregation 和 Event Sourcing， 这两种架构模式可以结合起来解决微服务应用中的事件流。

CQRS 将数据存储分离成两个独立的部分：一部分用于读取操作，另一部分用于写操作。度操作不会改变系统的状态，只获取系统状态。写操作会改变系统的状态，但是不会返回数值。

Event Sourcing 存储一系列的事件，这些事件发生在数据改变时。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429215250822.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

如上图所示，事件按顺序存储在Event stores中，数据查询模型中的数据与事件存储中的数据同步。为了让事件存储或查询模型，我们可以使用一些系统，例如 Elastic Search 来支持微服务中的查询。

这种架构可以用于处理微服务应用中的事件。

### 消息系统

我们可以使用消息系统或面向消息的中间件来支持事件驱动架构。

面向消息的中间件（MOM，Message-oriented Middleware），是一个软件或硬件基础设施，用于分布式系统之间发送和接收消息。MOM使得异构的应用模块分离，并降低跨多系统和网络应用开发的复杂度。中间件可以创建分布式通信层，避免开发者考虑操作系统和网络接口的细节。跨多种平台和网络的扩展，由MOM的API提供。MOM提供客户端/服务器架构模式的软件通信所需的组件，也支持异步调用。MOM减少应用开发者投入复杂的主从的客户端/服务器机制的原理。

与MOM通信可以使用不同的协议，例如
1. AMQP（Advanced Message Queuing Protocol）
    授权管理消息提供者和客户端的行为，可以实现多个对象之间的互操作。类似SMTP、HTTP、FTP。具体实现有：RabbitMQ、Apache Qpid、Red Hat Enterprise MRG
2. MQTT (MQ Telemetry Transport）
    MQTT是一种 发布/订阅模式，轻量级的消息协议，基于TCP/IP协议之上的。设计用于远程定位连接，带宽限制的和小编码的场景。更多在物联网IoT中使用。



### 分布式事务

大部分但不是全部的消息系统支持事务。当我们需要发送消息到消息系统，事务中改变数据时，也可以使用分布式事务。

分布式事务、两段提交（Two-phase commit）可以用于一个微服务，以及它的后端存储，但是不能在微服务之间使用。本质上要保持微服务的独立，因此具体的服务实例之间不应该存在密切的关系，例如两个服务之间需要两段提交。

对于跨服务的交互，事务补偿或和解逻辑应该添加以确保一致性。



# 6 应用安全

安全作为应用重要部分，必须要考虑。本章讨论在云原生的微服务架构下的安全要求。

## 6.1 微服务架构安全

微服务架构动态的本质，改变了安全的方式。安全与如何定义应用或服务边界相关。如下图所示，表示单块应用和微服务应用的请求流程图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430165652418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单块应用和微服务应用两者最大的区别，单块应用的组成是固定的，而微服务的组成经常发生变化。微服务独立更新。安全边界永远不够。如何以一种有机的方式保护这种快速变化的基础设施，级每个独立的服务可以自由改变和演进，而不需要中央协调。


### 网络分离

在上图中，两种风格的系统中都有一个分离的子网络，使用外部的防火墙或网关保护资源是一种比较好的方法。

如上图所示，外部API连接了两个不同的微服务应用，需要定义合理的应用边界，来分割多个独立的系统，这是一种很好的方式来保护动态的系统环境。

在主机环境网络分离很自然，例如微服务应用，如上图所示，每个微服务可以看做多租户（multi-tenant）环境中的一个租户。一般不会发生这种，除非需要这样。然而，微服务架构中管理网络的最佳实践是将外部管好。

### 确保数据隐私

不同类型的数据需要不同层级的保护，这些保护会影响数据的访问、传输、存储。

当需要处理数据时，可以考虑以下内容：
1.不要传输原始文本的密码
2.保护私钥
3.使用知名的加密技术，而非自定义
4.使用加盐的hash来存储密码，https://crackstation.net/hashing-security.htm
5.敏感的数据应该尽早被加密，尽可能晚的解密。如果敏感数据需要在服务之间流转，保持加密形式，除非需要需要用到这个数据。这可以避免意外泄露。

**backing service**
连接后端服务，作为网络中添加的资源，需要被保护起来。在很多云环境中，后端服务由云平台提供，依赖于多租户（multi-tenancy）和API keys，或访问令牌（access tokens）提供数据隔离。理解后端的这些特性至关重要，特别是它如何存储数据，确保满足监管要求（HIPAA， PCI等）。

**Log data**

日志数据需要权衡哪些用来进行问题诊断，哪些必须保护起来，出于监管和隐私原因。当输出日志时，充分利用日志的等级来控制数据如何输出。对于用户提供的数据，需要考虑这些数据是否原本属于日志内容。例如，我们是否需要将这个属性的值写入日志中，或我们是否真的关系它是否为null。

### 自动化

尽可能的让微服务自动化，包含一般的运维。可重复的自动进程应该应用于跨分片环境下申请安全策略、证书、管理SSL证书以及钥匙，避免人为错误。

信用证、证书、钥匙应该存储到一个地方，以供自动化使用，可以考虑以下建议：
1.不要将证书存在应用中
2.不要将证书存储在公共仓库中
3.只存储加密的数据




## 6.2 标识和信任

在高度分布的、动态的环境下，例如微服务架构，在建立稳定统一模式的标识上花费很大功夫。我们必须建立和维护用户的标识，而不会调用中心服务，从而引入额外的延迟或内容。

在这个环境中建立和维护可信不是那么容易，假设私有网络是安全的这种方式本身就是不安全的。端到端的SSL可以加密传输的字节，但是它不能只考自己构建一个可信的环境，它key管理方。

 本节讨论认证与授权，以及标识传播，用于建立和维护可信任的服务间通信。

### 认证与授权

微服务环境中需要认证和授权，在单块应用中，拥有细粒度的角色、角色与中心用户仓库相关联。微服务独立生命周期的重要性，像这种角色和用户的依赖是反面模式（anti-pattern）。开发独立的微服务受中心资源更新的约束。

专注的、中心化的服务或API网关创建认证（authentication，建立用户标识信息）是很常见的做法。这个中心的服务可以将用户认证信息代理给第三方。

当使用授权（auhorization，建立用户的权限，访问受保护资源权限的权限），在微服务环境中，保持组或角色的定义粗粒度是很常见的做法，跨服务切片。允许独立服务维护自己的控制粒度。将服务确保独立为基本原则。根据应用整体需求，权衡哪些在公共授权服务中定义，哪些在特定的服务中实现。


### 授权委托 OAuth2.0

OAuth 提供一个开源的框架，用于授权第三方应用访问。虽然框架定义了授权的交互模式，但是没有定义程序接口。具体参考：https://tools.ietf.org/html/rfc6749

OpenID Connect（OIDC）提供了一个基于OAuth2.0的表示层，委托认证至第三方。它定义了一个基于REST的互操作机制，建立在OAuth之上。具体可参考：https://openid.net/connect/

### JWT （Json web tokens）

标识传递是微服务架构中另一个具有挑战性的问题，当用户（human或 服务）已经认证后，表示需要以一种可信的方式传递到另一个服务。频繁的调用认证中心来校验表示是非常低效的，特别是通过中心网关路由的服务与服务之间的通信，会产生延迟。

JWT 可以携带用户的信息，可以完成以下任务：
1.知道用户的请求由用户初始化
2.知道请求的表示由谁产生
3.知道这个请求不是由前一个请求恶意重复的

JWT有契约的和URL友好的。从名称中也可以猜出，JWT包含一种JSON结构的数据。这个结构包含标准的申明属性，例如提交者、目标，过期时间。清晰的映射其他安全机制。JWT也提供自定义的空间，允许添加额外信息。

当我们构建应用的同时，我们很可能被告诫，JWT因为显示性而无效。对于安全和隐私原因，登录时将准确的错误信息告诉前端是一种不好的主意。这样做可能泄露具体的实现或用户细节。JWT.IO 提供很多有用的web工具，帮助开发JWT应用，具体参考：https://jwt.io

**处理时间**

JWT有一个优点是确定性地运行标识传递。当JWT过期，会触发校验JWT中的标识，从而产生新的JWT。JWT有三个字段与时间相关，都是可选的。一般来说，包括以下字段：
1.JWT创建时间（iat），在当前时间之前表示有效
2.“no process before”（nbf），在当前时间之前表示有效
3.过期时间（exp），在当前时间之后表示，jwt有效

这些时间都是以UNIX时间戳表示。

**Signed JWT**

签名JWT能在服务之间够建立信任，一个接收者可以校验签名者的表示，以及JWT的内容是否被更改过。

JWT可以使用共享的秘钥进行签名，或者秘钥对（public/private, SSL 证书）。

### 基于Hash的消息认证编码

使用基于Hash的消息认证码（HMAC，Hash-based Messaging Authentication Code）进行认证比HTTP basic优雅。当使用HMAC，请求信息被哈希编码并签名，用于创建一个署名，然后，包含在发送的请求中。当请求被接收，这个请求属性将被反哈希，用于确保数值是匹配的。这中方式可以认证用户，校验内容在传输中没有被修改。这种哈希标签可以疲惫重复的攻击。

HMAC校验能在API网关中使用。例如，网关认证用户，然后无论服务缓存响应信息、生成JWT或者其他自定义的头。使用JWT的好处是运行下游的服务一致地使用JWT来识别用户，将原来认证方法进行解耦独立。

HMAC不是完整的标准，API提供（网关或独立的服务）方经常需要提供不同的请求参数来生成签名。

建议使用HMAC共享库，因为HMAC需要在API消费者和提供方进行计算。

### API Keys 和共享秘钥

一个API key可以代表不同的含义，但一般用来识别原始请求。识别原始的请求在API管理中非常重要，比如 限流或跟踪。API Keys通常与账户的证书分开，根据需要创建或销毁。

一个API Key可以是一串字符，但是不像密码，这个字符串是随机生成的，超过40个字符长度。然而，优势字符直接在请求中使用，作为bearer token 或查询参数。使用API key可以让共享秘钥的签名的JWT更安全，或者数字方法（HMAC）。

如果服务创建API key，确保API key是以高度加密和正确存储的安全方式生成的。确保这些key能随时吊销。如果应用有分离的部分，那么为每个部分应该使用不同的API key。这样便于更细粒度的用户使用追踪，减少某个危险key造成的影响。

也可以使用非对称秘钥（例如 SSL），但是需要维护一个公钥基础设施（public key infrastructure，PKI）。虽然这样更安全，但是可以加大人力劳动，并且也很难管理，如果第三方也是API消费者。

考虑到12要素，秘钥应该依据配置注入，当微服务内部通讯时。这个secret不应该硬编码到应用中，因为这样会造成危险。


# 7 测试

微服务应用在建造的时候应该考虑到测试。好的测试能够让代码更加友好，正向影响持续提交流程。

根据应用组件的生命周期，可以分为以下几类测试：
1. 单服务测试
    由分离的团队实行测试
2. 临时环境
    在临时环境执行测试，微服务组成一个特别的应用部署到一个临时环境中，用于测试。
3. 生产环境
    运行在生产环境的测试
    
测试应该作为构建（build）、发行版（release）、运行（run）流程中自动执行的部分。

## 7.1 测试类型

在微服务中包含以下几类测试：
1. 单元测试
    单元测试是一个简单的类或者耦合相邻的类集合。这些单元测出可以使用实际的对象运行或者部署后使用test doubles 或 mocks。
2. 组件测试
    测试一个微服务全部的功能。在测试过程中，通过mock的方式调用外部服务。
3. 集成测试
    集成测试用于测试服务之间的通信，用于测试一个网络边界中最基本的成功或错误路径。
4. 契约测试（Contract）
    测试微服务中API和其他资源的契约程度。
5. 端到端测试
    测试微服务或应用中全部流程。通常用于测试一个全路径或校验应用，是否满足扩展的需求。
   

## 7.2 应用架构

微服务内部结构直接影响到测试的容易程度。如下图所示，一个简单的微服务内部结构。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190504201715368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

不同的部分需要不同的测试，例如，domain 逻辑层不需要集成测试，但是resource需要。分离的代码，导致微服务中相同部分需要相同的测试需求。这种技术使得测试套件简单并且更好的结构。由于微服务架构天生的复杂性，测试很容易别的复杂，因此，具有结构化的测试将有利于测试的开展。

## 7.3 单服务测试

单服务测试定义为独立服务拥有者需要创建和运行自己的测试。这些测试运行的代码是包含在逻辑边界中（logical boundary，如上图所示）。三种测试将应用在单服务中： 单元测试、组件测试、集成测试。单元测试和集成测试用于测试一个微服务中独立的部分，组件测试将测试整个服务。

### 测试业务功能

微服务中的业务代码不应该调用应用外部的服务，这些代码可以使用单元测试进行测试，例如JUnit。单元测试应该测试任何操作中实际使用的或mock的对象的行为。

### 测试Resources

提供资源的端点或接收事件的端点需要进行测试：集成测试（integration）或契约测试（contract test）

**集成测试**
集成测试应该用于检测跨网络的边界之间的通信。他们应该测试基础的成功或失败路径。集成测试可以采用与单元测出类似的方式进行，或与运行服务器一起。为了不需要启动服务器来运行集成测试，可以直接调用JAX-RS注解的方法。在测试过程中，创建mock的对象或资源类，当调用资源服务时。

集成测试应该验证应用基本的成功或错误路径。不正确的请求应该返回有用的响应，以及合适的错误码。

**消费者驱动契约（Consumer driven contract）**
一个应用中的消费者拥有一系列的输入和输出属性，需要对应的服务。这些输入和输出包括数据结构、执行和会话。契约可以使用Swagger这类工具，进行文档化。

消费者驱动契约测试是一个测试集合，用于决定这个契约是否支持。这些测试应该验证在契约中定义好的预期输入属性，同时也应该接受未知的属性，要验证资源服务返回文档中定义的属性。

维持消费者驱动契约测试会引入组织复杂性，如果测试不能精确的测试定义的契约，那么这些测试将是无用的。此外，如果契约过时了，即便是最好的测试也不能产生有用的资源。因此，消费者驱动契约测试需要保持更新状态，与当前消费者的需要同步，这样才能确保测试精确。

契约测试需要实际的API。可以使用Swagger editor来创建测试。测试运行在服务器端。

    tests on running server
    启动和停止服务作为自动化测试的一部分，有一些方法可以实现。例如Maven和Grade的插件。例如 WebSphere Application Server Liberty
    Maven https://github.com/WASdev/ci.maven
    Grade https://github.com/WASdev/ci.gradle
    
 另一个契约测试维度，契约测试运行在消费者端。这些测试应该运行在消费者可以访问运行版的服务环境中，stagin environment。具体可以参阅 7.4.3节。



### 测试外部服务请求

不可避免地，微服务需要调用外部服务来完成一些请求，例如调用应用之外其他微服务或服务。提供这些功能的类，构建一个客户端来发起请求并处理失败的请求。测试外部服务的请求，可以使用两类集成测试方法：一个是在单服务级别，一个是在staging 环境下。两种测试方法都测试客户端基本的成功和错误处理功能。更多可以参阅7.4.2.

单服务层级的集成测试不需要服务在测试下，或外部服务被部署。为了执行集成测试，需要伪造外部的服务进行响应。如果使用JAX-RS2.0 客户端调用外部请求，可以使用JMockit框架进行测试。

### 测试数据请求

在微服务架构中，每个微服务有自己的数据。如果根据这条开发指南，一个微服务的开发者可能负责一个外部数据存储（data store）的使用。如7.2节，应用架构图所示，执行外部数据的映射和校验包含在repository层。当我们测试domain逻辑层时，这个层需要进行伪造。测试数据请求，微服务中集成测试用于测试数据映射或验证，需要在本地或私有云中部署一个测试的数据存储。测试数据请求的基础的成功或失败路径。如果数据映射或验证需要扩展测试，可以尝试将这部分代码分离出来，使用伪造的数据客户端进行测试。

**测试数据**
本地版本的数据存储必须包含测出数据，并且思考哪些数据需要放到数据存储中。这些数据应该与生产环境中的数据结构一样，没必要太复杂，应该可以满足指定目标的数据请求测试。

### 组件测试（component testing）

组件测试用于测试每个微服务。组件是网络访问中任何一块，因此调用外部服务可以使用伪造或替代的“test-service”进行测试。两种方式各有优劣。

**使用mocks**
伪造调用外部服务的请求，需要配置很少的测试对象。如果能够很容易地定义伪造系统的行为，例如使用JMockit，没有测试会应为网络问题而失败。这种方法的弊端是，这些并没有完全使用组件，因为我们截断了一些调用，增加了这里面的bug风险。

**Test Service**
为了使用微服务完整的通信边界，我们创建一个测试服务，来模仿生产环境中调用的外部服务。这种测试服务可以包括数据测试。测试服务也可以当做微服务的消费者使用。弊端是，这种方式需要我们维护测试服务，也需要更多循环处理，需要更完整的测试来测试微服务并创建一个部署的管线。

当我们使用mock框架进行其他级别的测试，重复使用这种技能也是有意义的。然而，如果我们使用mocking方法，必须确保这些staging环境下的测试能有效使用服务内部的通信。

### 安全检验

在服务式系统中安全非常重要，我们不在将应用放到防火墙后面，并假设不会有东西打破这层防护。

根据我们实现安全方式的不同，微服务中的安全测试稍微有所不同。如果每个独立的服务都做token验证，那么安全测试在这个服务级别。如果使用其他服务或库来验证tokens，那么这个服务需要独立测试，并且staging环境下的交互也需要测试。


## 7.4 临时环境（Staging Environment）

这部分定义一个临时环境作为测试环境，与生产环境尽可能相同。组建管线部署成功地测试微服务架构至临时环境，验证微服务中跨逻辑边界的通信。

### 测试数据

临时环境应该包括生产系统中任何类型的数据存储。这些存储中的数据比每个服务层级的数据更完整，要测试更加复杂的交互。

使用工具注入数据来测试。这些工具可以能提供系统中数据流的控制，测试当有坏数据引入发生的问题。

### 集成测试

集成测试用于测试系统中所有服务之间的交互。在这个阶段测试每个独立服务深度的行为。消费者驱动契约测试应该确保服务之间成功地交互，而不是仅仅定义失去的bugs。需要测试服务通信之间基本的成功和失败路径。

在测试工程中可能需要伪造某些服务，而不是一次测试所有的服务。测试两个指定服务之间的交互，或一部分微服务之间交互，当调用这部分微服务之外时，添加伪造的行为。伪造服务外部的调用与API的单元测试采用一样的方式。相同的技术来进行启动、停止服务器或容器。

### 契约

每个消费其他服务或资源的服务，应该拥有一部分契约测试，这些测试运行在资源（特别是临时环境）之上。为了让服务能独立的演进，很重要的一点是确保消费者契约能持续满足要求。

这些测试由消费者编写（客户端），作为消费服务器测试工具中运行或管理的一部分。相反，资源测试由提供者信息编写，并验证整个契约。

### 端到端

端到端测试是用于查找之前缺失的bug，端到端测试应该使用应用中合适的“黄金路径”（golden paths）。用端到端测试整个应用中的路径是不现实的，因此识别主要的路径进行测试。有一个很好的方法识别这些路径，预览应用主要的外部需求。例如，一个在线应用零售店的系统，可能需要测试这些路径：
1. 用户登录
2. 用户购买一个商品
3. 用户浏览订单信息
4. 用户取消订单

端到端测试应该包含用户界面，例如 SeleniumHQ 可以自动测试Web交互。

### 容错和弹性

一个微服务应该包含容错设计，因此我们需要测试微服务中的容错和弹性功能，容错测试应该在所有服务部署下进行，而不是使用mock。

**拆卸微服务**
在一个微服务系统中，我们不能依赖所有的微服务在任何时候都可用，在测试阶段，当拆卸、重复部署一个服务时发起请求。这个过程应该包括微服务以及后端的数据存储。监控请求返回的时间，识别一个可接受响应的时间。如果响应时间太长，考虑到减少timeout的时间或警告熔断配置。

有很多自动化工具可以帮助测试，例如，Java社区非常有名的Netflix Chaos Monkey，可以终端一个虚拟机的实例来进行容错测测试。https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey

另一个工具，例如 Amalgam8中使用的 Gremlin， 截断和手动调用微服务，而不是停止实例。
https://github.com/ResilienceTesting/gremlinsdk-python

**注入坏数据**
正如集成测试中，像Amalgam8可以用于注入坏的数据，进行测试。如果微服务中使用了隔板模式，当有一个微服务中有坏的数据时，不会传递到其他微服务。

**压力测试**
微服务应该能够处理异常的负载，压力测试应该测试微服务中的隔板，如果一个实际的微服务能够顶住请求，可以查看一下bulk head配置。

**可恢复性测试（recoverability testing）**
一个微服务应该具有弹性能力，如果容器或虚拟机宕机，微服务应该能够快速恢复。编排工具，例如 kubernetes会启动新的实例，如果应用宕机。一个微服务应该快速启动，当一个服务需要停机时，应该能平稳的停机。

使用实例拆卸的方式进行恢复性测试。使用编排工具创建新的实例，并监控重启一个新的服务需要花费多长时间。

## 7.5 生产环境（Production Environment）

为了测出系统，我们应该考虑生产环境下的运行情况。由于很多变迁的部分以及服务持续的添加或移除，我们不应该期待系统能够继续完美而不确定性的工作。添加监控和分析应用来警告任何坏的行为是非常重要的。

生产环境也需要开展临时环境下的测出：
1. 注入坏数据测试
2. 宕机测试，测试服务的容错性和恢复性
3. 安全验证

可以使用与临时测试环境一样的工具，但是我们需要注意这些运行这些测试，不要在高峰值时，运行这些测试。选择一个时间集合，对客户端应用影响很小的时候运行这些测试。

### 综合监控（synthetic monitoring）

为了检测生产系统的健康状态，创建综合事务贯穿整个应用。使用浏览器仿真器生成综合事务和监控响应。查看无效的响应或大范围响应时间。周期性的自动构建系统。如果提交经常提交新的代码，构建将频繁运行，但是很可能实际的服务可能需要一段时间，当有少量的提交时。在这段时间内，如果继续运行构建，将发现任何应用依赖的改变可能导致问题。


### 金丝雀测试（canary testing）

金丝雀测试名称由来于矿洞前期入洞前检测矿洞内环境是否对矿工安全。最小的测试用于验证一个服务的所有依赖和基础的操作需求功能。如果环境是不安全的，金丝雀测试将快速失败，提供一个较早失败的指标。








# 8 从开发环境到生产环境

本节讨论如何构建微服务、部署微服务。通过这节内容，促进开发环境到生产环境的平滑移动：
1. 一个微服务必须独立部署
2. 一个新版本的微服务应该在一分钟内部署完毕，而不是一个小时
3. 一个微服务应该具有容错能力，能够避免雪崩式的失败
4. 一个微服务可以不改变代码就部署到不同目标环境

微服务架构需要很好的自动部署工具，帮助管理部署、测试和提升服务跨目标环境。

本章主要包括以下几个主题：
1. 部署模式
2. 部署管线和工具集
3. 打包方式
4. 跨阶段的应用配置

## 8.1 部署模式

传统单块构建和部署于一个单元上。单块应用构建时包括多个部分、多个Java平台、企业编辑文档。微服务与此相反，每个微服务独立部署。这样微服务配置提供更具弹性的消费者应对服务改变：
1. 蓝/绿部署
   蓝绿部署时一种很常见的单块应用部署模式。这个方法的关键点在于我们需要维护两个工作环境的版本，例如一个可以作为另一个回滚，如果部署失败的话。这个过程包类似：
   a. 一个蓝系统正在运行
   b. 启动一个绿系统，测试该系统，验证它是否工作正常，然后将流量切换到绿系统。蓝系统作为独立运行以便发生绿系统发生失败的时候回滚
   c. 当绿系统运行稳定后，蓝系统将准备下一次更新，这个过程由相关替换，从绿到蓝
   
   在微服务环境下，一个备份的环境经常应用。每个系统(蓝、绿）包含所有运行稳定的微服务版本，由配置管理进管理。以这种方式周期性、协调的更新非耦合的服务。
   
2. 金丝雀发布

金丝雀发布也被认为是阶段或增长首次增长。一个金丝雀发行目标是发现部署新版服务时的失败。类似蓝/绿部署，金丝雀发布作为备份环境的起始。

3. 开关（toggling）

toggle 特性是服务内部用于启动或关闭新功能的标识。这个过程可以有效的服务消费者选择性的测试新功能（可能使用自定义的Http头），而不需要维护不同的服务版本或工程师首次协作。开关在单块应用中很常见，作为一种保护机制，避免变化对已有的消费者产生影响。

开关可以在环境中设置，一个服务可以打开或关闭某个功能。这些功能可以动态配置，以二进制的方式对服务运行，或者可以结合每个请求机制，例如HTTP头，来打开或关闭每个请求上的新功能。

toggles可以用于路由决策，可以作为中心服务的金丝雀版本的选择器。他们可以用作A/B测试，即一对一的进行可选实现方式的对比。


## 8.2 部署管线和工具集

微服务架构另一个优势就是敏捷性，由于每个独立的服务可以聚焦到一个范围，一个独立的生命周期，这使得可以花费更少的时间，将新的功能以微服务的方式实现，测试这些服务，部署这些功能到生产环境。微服务经常迭代构建，这意味着支持持续集成或部署。

待部署的artifacts经常运行在不同的系统，因此，为了使服务可以工作，很多系统需要进行配置。手动维护微服务到生产环境的部署步骤越多，越容易引起异常的错误，由于坏的输入或忘记某个步骤。人为干涉应该尽可能少。例如，在一个新版的服务部署到生产环境，由于某些原因可能手动方法，然而，都可以自动化。

根据Martin Fowler描述的部署管线（[Deployment Pipeline](https://martinfowler.com/bliki/DeploymentPipeline.html)）作为持续交付（[Continuous Delivery](https://martinfowler.com/bliki/ContinuousDelivery.html)）环境的一部分。部署管线描述了一个微服务到生产环境的步骤集合，通常将这个过程分为多个阶段，包含构建（building）、部署（deploying）和每个阶段的测试。[DevOps技术](http://blog.xebialabs.com/2015/07/20/xebialabs-launches-the-periodic-table-of-devops-tools)可以简化部署管线的创建，相关的工具链支持将应用从开发环境部署到生产环境。

前面提到过，微服务的源码应该放到代码管理（SCM，Source Code Management）工具中，例如 Subversion，Git。微服务应该使用依赖管理工具，例如 Maven、Gradle。选择一个仓库来存储我们共享的代码库，例如,[Nexus](https://blog.sonatype.com/) 或 [Artifactory](https://jfrog.com/artifactory/)。使用持续集成工具（CI-Tools），例如，[Jenkins](http://jenkins.io/) 或 [Bamboo](http://www.atlassian.com/software/bamboo)。

在自动化构建完微服务后，需要进行测试，有些测试需要部署微服务，这意味着在自动预分配的系统中设置好正确的配置。我们可以使用经典的脚本工具来正确的配置目标，但是我们可能管理平台或系统不同的脚本。脚本框架，例如 [Chef](http://www.chef.io/)，[Puppet](http://puppet.com/)，[Ansible](http://www.ansible.com/)， [Salt](http://saltstack.com/)能很好地处理这些情景。这些框架也可以用来初始化安装、修改已有的系统。我们描述配置文件的目标内容，这些工具可以处理不同目标系统变化产生的差异。

容器化技术也可以帮助我们获得正确配置的系统，对于动态预分配下，我们可以使用云主机服务基础设施即服务（IaaS），或者平台即服务(PaaS)。由于在我们系统中可以有大量的微服务，因此 一个Release Management 工具对我们来说很有用。我们必须监控大部分部署的系统，收集日志，用于审计或诊断。此外，还应该扫描微服务中的安全漏洞。

Maven和Gradle作为很好的构建工具，可用来创建微服务，并且能够管理JAR文件的依赖。两个工具都可以列出构建微服务所需要的Jar包，一般来说一个有区别的版本指示器可以让每次构建变得清晰，那个版本是部署的。

微服务模板可以帮助需要开发相同实现的微服务，例如 日志管理，在微服务系统中是必要的一部分，跟踪微服务之间的请求也很有用。如果每个微服务的开发团队，编写自己的日志管理模块，使用自己的日志格式，那么不同服务的日志文件的聚合将变得非常困难。安全也是基本需求，应该在统一的规范下进行开发。模板可以编写这些公共关注点，将这些写入惯例中，便于遵从。然而，有些开发者觉得这些模板太过约束，他们想忽视或摆脱这些要求。因此，规范在开发者之间需要进行权衡，避免构建的模板带来不好的影响。


## 8.3 打包选择

当我们构建完微服务后，选择哪种打包格式进行部署需要考虑。根据12要素以及云原生应用定义，创建不可变的artifact，运行到不同的环境而不需要更改代码。

部署到中的变化越多，风险越高，由于缺失配置，缺少依赖。

构建不可变、自包含的artifact，引入部署和的一致性，产品环境。

对于Java，一下是多种打包选择：
1. WAR/EAR 文件部署到预安装的中间件上
2. 可执行JAR文件
3. 容器
4. 每个微服务拥有自己的虚拟服务器

一般而言，我们可能想最小化服务部署、测试的环境差异，以及生产环境。有些打包和部署方式，使得分离部署和生产环境十分容易。以下是每种打包方式的优点和缺点。

### JAR、 WAR、 EAR

这些都是Java EE 应用默认的打包形式，WAR 或 EAR 需要部署到一个专门的系统中，例如 Tomcat容器。

应用从开发环境到生产环境可能经历不同临时环境、不同的宿主机。虽然每个环境有相同的配置，但不是所有的情况都是这样。例如，相比开发或测试环境，生产环境可能需要更加保守的方法来进行更新。

这种方法可能产生以下几种问题：
1. 很难实现短时间频率高的部署，例如，一天活一小时。有些应用需要重启应用服务器，这样可能影响同一个服务器上的其它服务。这种影响不可能每天或每小时执行。
2. 如果不同的应用都部署在同一个应用服务器，那么一个应用可能的加载可能会影响另一个应用的性能
3. 基础设施很难适应，应用程序加载时的高速变化
4. 开发者和运营管理者的责任分离，可能导致很难确定部署问题由谁造成

如果这种模式在微服务中使用，那么服务和服务器应该是一对一的关系。这种配置很常见，例如，PaaS环境下，我只需要推送WAR 或 EAR来刷新构建的服务。在中间件实例中部署隔离的服对保持服务的独立伸缩性是非常重要的，并且这有利于降低服务升级对其他服务的影响。

正如上面提到的，这种部署方法仍然有风向，即便服务已经隔离，但是仍然运行在中间件中以提供服务运行所需的依赖。然而，因为反映了大部分传统单块应用的经验，当我开始一个新的微服务应用时可以作为第一步来进行。

### 可执行JAR文件

为了避免依赖部署环境以提供包所需要依赖，我们可以将应用打包至可执行的JAR包来运行服务。这个大的JAR文件包含服务类文件，以及支持的共享库，包括Servlet容器或其他java EE中间件。这种技术消除由于开发和测试环境与生产环境依赖不一致造成的部署问题。

自包含JAR文件一帮容易处理，可以创建一致、可复写的环境，用于本地开发是测试，以及部署到目标环境中。

### 容器

前面的阶段需要部署到操作系统中才能运行，即必须安装操作系统，并且需要配置运行JAR的环境。为了避免不同操作系统配置不同的所引发的问题，我们需要一种策略保持微服务在操作系统中有相同环境配置。

容器是一种轻量的虚拟化技术，能够在一个操作系统上运行。[Docker](http://www.docker.com)提供一个基础设施，能构建完整的文件系统，包含所有用于原型应用所需的操作系统的元素（工具、库），以及应用自身。Docker引擎是一个轻量的运行时，提供容器、宿主机以及支持工具之间的抽象和隔离。

Docker容器可以隔离多个应用，分离宿主操作上的应用。容器隔离和轻量化属性使得在一个操作系统中可以运行不止一个Docker容器。这个配置意味着我们不需要很多虚拟服务来按照微服务所需的操作系统。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518220750854.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

Docker镜像是不可变的artifact。当一个应用编译成Docker镜像后，这些镜像可以用于启动不同部署环境下的容器，确保相同的技术栈用于所有环境中。使用Docker容器后，应用以怎样的打包格式就不重要了，这些镜像的配置来决定容器如何启动。微服务的配置包含在容器中，可以使用环境变量或者挂在的volumes。

微服务所需的Data store是或其他后端不应该包在同一个容器中。这些后端也作为服务，是微服务的一个重要特征。数据存储，例如也可以有Docker容器来管理。一般而言，我们不应该将同一个服务的多个实例安装到同一个宿主机内。


### 一个微服务独立一个服务器

为了保持多个阶段的操作系统统一，需要使用相同虚拟化的服务，作为每个阶段的基础。为了实现这个目标，安装操作系统和其他所需的工具，然而创建一个服务模板。

使用这个基础模板来创建每个微服务的系统服务，是另一个不可变服务。

我们可以使用虚拟工具、云平台和第三方选择来管理这些服务和服务模板。某些第三方选择可用，包括Vagrant、VMware、VirtualBox。当使用软件配置和自动化技术，例如Salt和Ansible，使独立服务上的微服务虚拟变得更具弹性。

这种方式可以产生两种：
1. 将微服务打包到单个虚拟服务器上
2. 一个虚拟服务部署多个微服务包

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518220817250.jpg)

当每个虚拟服务器上不是一个微服务，这种方式很好的隔离多个虚拟服务器，运行多个微服务。针对特定微服务的需要可以修改系统配置。当错误发生时，可以很容易的分离不相关的信息或其他服务的影响，来定位问题。这种不相关的应用减少影响可以有利提升性能。一个应用不能占用另一个隔离的服务的资源。

这种方式的缺点是，每个虚拟的服务器需要统一和协调管理。所有的资源消耗也很高，因为每个虚拟服务器需要自己独立的操作系统。某些虚拟解决方法有对这个问题做优化，可以减少多个操作系统处理器的使用。

只有当多个微服务有相似的资源使用模式，才适合部署在一个虚拟服务器上，这样可以降低服务之间的影响。

操作系统应该具有将多个微服务部署在同一个虚拟服务器上的配置。不同的配置之间不应该相互影响或在多个阶段与操作的的配置发生冲突。从共享系统配置的成本上考虑，这种方式能有减少部署微服务所需的虚拟系统数量。在这个配置下，我们可以使用JVM中的共享类缓存，这能减少启动微服务的次数。


### 一台服务器运行多个微服务

本节的内容，适合一个服务器上部署多个微服务，无论使用容器或虚拟系统的方式实现。

如果在服务器上部署多个微服务，那么需要注意Java运行时的线程池优化。JVM查询操作系统，获取服务器的CPU核数，根据这个信息定义管理线程池的策略。当使用虚拟硬盘时，JVM通常会获取错误的可用资源的信息，这是由于服务器上每个JVM所看到的相同可用CPU信息，甚至很少考虑一些特殊进程对于可用CPU的数量。这种情景容易在某些线程池切换算法中引起异常，由于无法获取预期中的CPU个数，可能触发错误的优化。

从其他方面上看，我们应该考虑微服务如何在相同的服务器上共享或竞争服务器上的资源。提取了解每个微服务的资源需要，或获取解决这个问题的数据，避免这类问题发生。例如，随着缓存的增长，微服务内部的缓存可能引起问题。因此，一般在系统外部实现缓存。外部的缓存服务应该看字服务的附属，就像数据存储（data store）一样。

### 最佳实践

抢眼一看，在同一个服务器上运行多个Docker容器打包方式的微服务与在同一个服务器上运行多个微服务包是一样的。但是深入分析后，这两种是显然不同的部署模式。同一个服务器上运行多个非Docker容器化的微服务，只能在所有微服务需要相同配置的操作系统条件下进行。然而，容器提供更加高级隔离机制，同时重复利用宿主机的资源与公共的底层操作系统。微服务需要不同或冲突的操作系统配置可以很开心的在Docker容器中运行。

以下是比较喜欢的打包实践：
1. 虚拟化或云服务一般作为基础设施，由于他们提供动态的资源来帮助系统或微服务处理容量上的需求变化。
2. 在每个部署阶段应该保持系统级别的配置一样，或者应用之间应该隔离，例如使用容器技术
3. 微服务应该打包成不可变的包（Immutable artifact），能促进各个阶段的不可变能力
4. 对于微服务的Immutable artifact，应该独立运行并且自包含（self-contained）。例如可执行的Jar包或Docker容器。
5. 每个Immutable artifact应该包含一个微服务应用，以及他所支持的运行时和库。
6. 当主持共享资源来避免自己竞争引起的冲突，应该考虑资源需要
7. 共享库应该作为应用的一部分，而不是有宿主机提供共享或依赖。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019051822084736.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

上图显示的是Java EE的微服务，以Docker容器的方式打包。





## 8.4 跨阶段应用配置

每个微服务应该是一个不可变的部署包（immutable deployment artifact）。在它构建完成之后，不同的部署环境不应该改变其中的内容。因此，各个部署环境下，环境变量可能不一样，这些需要再部署时注入到artifact中。此外，使用不可变服务器（immutable server）来部署，应用配置应该尽可能的保持不变。只需要改变不同服务器上的配置的值，例如（端口，IP地址，数据库用户名，线程池大小），其他应用的配置应该尽可能保持一致。我们改变的值越多，那么我们在部署到下一个环境中的风险越高。如果这些值在后续阶段中需要改变，我们应该测试这些改变后服务表现的行为。

微服务的配置可以使用不同的方式：
1. 环境变量
2. 配置文件
3. 配置系统

### 环境变量

一种获取微服务外部配置的方式是，使用环境变量，这是一种比较常用的方法来向运行的进程中传递数值。

环境变量都是基于字符的Key-value键值对的形式，这种方式设置不同操作系统的值。

使用环境变量相比传递系统属性（Java command line option -D）至微服务更好，因为在云环境下，我们一般不能直接访问进程的命令行。云环境通常使用环境变量。

例如 Cloud Foundry提供一个VCAP_SERVICES的环境变量，它是一个JSON文档，包含服务实例的信息，
https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES

Spring boot中有个Connector可以访问这个变量


https://spring.io/blog/2015/04/27/binding-to-data-services-with-spring-boot-in-cloud-foundry



### 配置文件

在Java应用中，另一个可选的获取配置数据的方式是使用JNDI（Java Naming and Directory Interface）API来查询目录服务。每个JavaEE应用必须JNDI能力，每个在JNDI命名空间中定义的元素可以注入到java CDI，这样访问这些数值就很容易了。

Spring Boot提供应用外部的配置文件，一般使用YAML文件来进行配置。

https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html


### 配置系统

第三种可选的方法来配置微服务系统，使用特点的服务器。这些配置系统与Key-value存储一样可以持久化配置不同微服务。

根据CAP原则，我们必须选中其中的两项。在微服务系统中，缺少配置系统将无法工作，配置系统必须是分离的，这意味着我们配置系统只能是具有不一致的数据但可用，或者具有限制性的可用但是数据是一致的。

以下是微服务体系典型的配置系统：
1. Apache Zookeeper http://zookeeper.apache.org/
2. etcd https://coreos.com/etcd/
3. Netflix archaius https://github.com/Netflix/archaius
4. Consul http://www.consul.io/

根据CAP原则，ZooKeeper 和 etcd 是CP系统， Archaius 和 Consul是 AP属性，每个系统都可以再Java应所有中使用。根据具体的微服务应用需求可以选择不同的配置系统。

使用配置系统的优势是配置数据可以在运行时进行修改，这些改变不是由环境变量或配置文件实现的。

### 程序

微服务的配置代码不应该在业务逻辑中完成，最好在中心的位置进行这些配置编码。在大多数情景下，访问配置数据是基于技术决定，这不会影响业务逻辑。

如果配置系统使用CDI（Contexts and Dependency Injection），那么我们必须处理运行时的数据值改变。在这种情况下，CDI Bean的注解 @RequestScoped（或者 @Dependent）需要确保每次请求时这些数值被刷新。某些配置系统提供回调机制来获取客户端的信息，当发生数值改变时。结合CDI的producer（@Produces），我们可以很容易的附加配置系统到我们应用中。



### 最佳实践

综上所述，以下是配置的最佳实践：

1. 配置应该保持到部署包的外部，可以采用三种方式进行配置（环境变量、配置文件、配置系统）。这几种配置方式取决于应用的需求。

2. 动态配置数据应用有配置系统进行管理，但是应用必须对配置改变进处理

3. 尽可能的保持系统是不可变的，这条准则可适用于配置上以降低风险

4. 微服务的业务逻辑不应该处理配置数据，这些应该在中心helper 类或包中进行。


# 9 管理和运维

微服务与单块应用的运行方式有几方面不一样。在微服务中，但应用可以变成一个分布式系统，由多个相关关联的微服务组成。因此，我们必须管理高度分离的系统，以及每个服务之间的通信。

运行中的服务比单块应用中的服务运行更高。当加载的特征变化后，一个微服务应用应该快速调整多个运行的服务进行响应。因此，我们必须自动化的部署新的、移除就的服务实例，来确保所有的应用运行合适的状态。

在每个生产系统中，有必要进行健康检查，来获取应用运行的信息。在微服务中，也需要对每个服务实例进行健康检查。

本节包含以下三块内容：
1. 指标和监控检测
2. 日志 (Logging）
3. 模板（templating）

## 9.1 指标度量和健康检查

指标度量和健康检查是获取运行中服务状态的一种必要方法。

### 动态供应（dynamic provision）

使用动态供应，为了自动化保持微服务系统在最佳状态下运行。这种状态时系统适合保持应用用户负载需求之间的平衡。让足够多的服务实例是有效工作，来支持吞吐量和保持应用延迟的最小化。例如一个微服务实例可能变得过载，这时可以弹性的启动另外一个服务实例来扩展。这种变化应该自动化的运行，而不需要管理员干涉。类似的，负载低的、无用的微服务实例将会停止，释放虚拟系统的资源。

然而，在某些情景下，需要通知管理员某些阈值已经达到了，需要他们采取行动来避免系统宕机，当然，这是异常场景。

服务发现是微服务中关键的服务之一。服务注册与发现服务会跟踪可用的微服务实例，以及他们当前的健康状态。新的服务实例应该开始处理请求，来减小原来实例的负载。知道新注册的服务后，负载均衡器可以动态的执行，可以最优的性能向多个服务实例中分发负载。一个微服务在被关机前，应该完成正在执行的请求才行正常关机，不应该再接收新的请求。

微服务系统需要高度自动化来实现上述这些行为。可以使用基础设施管理的各种工具了帮助我们，很多打包的方式可以实现这个任务目标。在微服务包中的运行环境具有一些支持自动化的特性。使用Liberty作为运行环境，可以提供我们某些领域的自动伸缩和动态路由。

自动伸缩（auto scaling）提供一种动态伸缩的能力。自动伸缩功能由两个Liberty特性完成：Scaling 控制器和scaling成员。Auto Scaling动态调整JVMs的使用数量，来支持负载。这个特性提供弹性运维，并减少管理员的需求，增强中间件的恢复力。Auto scaling的条件由伸缩策略定义。这类条件包括服务实例最小或最大个数，以及每个服务器资源的阈值。

微服务运维通常采用一种模式，始终保持一定数量的微服务实例处于运行状态，或经常保持最小数量以及权限运行的级别下放大。通过这种设置的一个微服务应用，在它自身的设计边界内运行，并且在异常负载下能扩大服务至可接受数量来承载这些压力。使用Liberty的自动伸缩特性，对于一个简况的系统，我们可以定义服务实例的最小运行数量。我们可以管理系统来保持这些数量的实例处于在线状态。

自动弹性度量，主要包括以下几个方面：
1. CPU
2. Heap
3. Memory

### 健康检查

我们需要识别微服务应用中的实例所发生的问题，这样我们可以确保整个系统处于健康的状态。为了获取这些微服务的信息，Liberty具有一些其他的功能，健康管理，可以帮助我们采取一种策略驱动的方式，监控应用服务器的环境，并当发现非健康时采取行动。我们可以定义健康政策，包括我们环境中的健康条件，以及当发现非健康条件时的应对行动。

健康管理能避免服务因发现常见的问题而瓦解，基于健康政策配置来创建诊断行动。健康管理功能由两个特性组成：
1.监控管理员 2.健康分析员

以下预定义的健康条件可供参考：
1. 过多的请求超时条件
2. 过多的响应时间 条件
3. 内存条件：过多的内存使用
4. 内存条件：内存泄露

当这些健康条件产生时，可以执行一个预定义的行为。以下行为可参考：
1. 重启服务器
2. 将线程的内存转储
3. 将JVM堆内存转储
4. 将服务器切换为维护模式
5. 将服务器退出维护模式

上述行为可能产生更多信息（线程、堆内存转储）来获取对问题更好的理解。这种特性使得Performance Monitoring Infrastructure（PMI）来处理其他运行中的服务器。



## 9.2 日志（Logging）

日志是应用中重要的一部分。也是微服务系统中重要的一部分。

在一个微服务系统中，业务事务可能横跨多个微服务，如果我们微服务使用一个消息中间件，那么这部分也属于业务事务。因此，我们需要跟踪系统中整个请求，直到响应从系统中离去。一种监控这些请求的方式是，使用关联ID（correlation ID），在消息中间中使用相同的关联ID来对应微服务中的请求。

我们可以创建关联ID在请求进入系统时，然后，发送相同的关联ID到其他微服务，当调用它时。其他的服务只需要检查是否存在一个关联ID，并且传递到它的调用中。这个关联ID能够放到HTTP的请求头中，使用特定的字段来保存这个值。可以使用REST过滤器来处理这个头部字段，可以中心化这段处理逻辑。

使用关联ID提供以下几点好处：
1. 容易找到级联式错误
2. 跟踪用户的请求，来获取更多用户典型的行为信息。
3. 可以找到没有使用或很少使用的微服务，并讲这些服务排除；或者找到重度使用的微服务，然后，将这些从这些服务中挖掘更多商业价值

使用日志框架来记录关联ID的日志到文件中有很多好处，某些框架可以使用日志上下文，SLF4J、Log4J实现了Mapped Diagnostic Context（MDC） 或 Nested Diagnostic Context（NDC），可以将关联ID放到这些里面。因此，每条日志状态写入日志文件，包括NDC或MDC。另一个好处，我们可以从NDC或MDC中获取，如果我们使用了多线程来响应请求，那么每个线程记录相同的NDC/MDC.

日志的输出格式应该由一个中心的机制进行定义，这样聚集不同微服务所产生的日志更加容易。日志的等级（例如，FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL）应该清晰的定义，并且在相关的每个微服务中使用。否则，我们可能无法理解两个不同微服务团队的日志。

在使用动态供应的微服务系统中，我们必须确保微服务所在的服务器在关机时删除日志文件。在这种情况下，最好使用日志基础设施，它长期运行来收集微服务输出的日志信息。这个日志系统可以帮助我们收集分布在不同系统中的日志文件。搜索不同服务器上的日志文件是一个非常费时的操作。在生产环境中，这些操作将会受限，在这些系统中通常我们都没有权限或最小的权限。

因此，更好的方法是在微服务应用中建立一个日志基础服务，例如ELK（Elastic Logstash Kibana）：
1. Elasticsearch 搜索与分析引擎
2. Logstash 数据收集和传输管线
3. Kibana 数据可视化


## 9.3 模板（Templating）

从管理者的视角，将实现系统或微服务模板化，对于我们开发团队是有价值的事情。模板在这里是指，定义一个代码片段的骨架，能有用于生成微服务所需的部分。

典型的微服务模板包括以下常见的能力：
1. 与服务发现进行通信，注册服务实例
2. 与其他微服务进行通信
3. 与消息系统进行通信
4. 日志
5. 安全

使用模板我们将获得以下几点能力：
1. 快速开始一个开发团队
2. 所有团队使用相同的跨功能服务

以下是可用的模板生成工具：
1. WildFly Swarm Project Generator
2. Spring Initializr
3. Liberty app accelerator

如果所有的团队使用Java来实现微服务，那么我们不需要一个多语言编程环境，那么我们必须定义一个模板，一个最能契合我们需求的模板。







