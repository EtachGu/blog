# 微服务简介(MicroService)

微服务是一种架构风格，一个或多个小的微服务组成一个复杂、庞大的软件应用。每个微服务集中在完成一个较小业务能力的任务。这些微服务可以用任意语言开发。

Martin Fowler’s 定义的微服务，微服务用于组成复杂的应用，微服务够小，独立、进程可替代、微服务之间使用轻量级的API， 并且微服务不依赖统一的开发语言

更多信息参考：Martin Fowler的论文“Microservices: A new architectural term”, http://martinfowler.com/articles/microservices.html


## 微服务多小才算小

微服务大小不是由代码行数决定的，微服务足够小，聚焦在特定目的。微服务应用做一件事情，并且做好这件事情。

## 独立和自治（independence and autonomy）

为了确保每个服务在创建、维护时保持敏捷性，每个服务应该独立和自治。每个服务能够在任何时间启动、停止、替换，不会紧密与其他服务绑定。微服务其他要素遵循这一点。

微服务架构风格应该扮演一个包装来守护应用的具体实现细节。这种配置允许服务的实现，以后可被修订并且提升（甚至重写）。特别是数据源必须是服务私有的。

## 弹性和容错（resilience and fault tolerance）

服务需要具有弹性的能力，也就是说在动态的云环境中，服务需要预测和平缓地响应异常，即当服务接收到错误的数据时，不会影响到后台服务（Backing Service），或者处理分布式系统中并发更新的冲突。

独立演进但是相互之间存在依赖关系的服务，鲁棒性原则提供最佳指导：“对接收的可以进行自由操作，对于发出的需要谨慎处理”。  假设API会逐渐演进，对于无法理解的数据能够容错，引用RFC：
    简单举例，一个协议包含多个枚举值，这些枚举类一定是不完整的。因此，如果协议定义了4个可能的错误码，当服务接收到第5个错误码时，服务不会宕机。无法识别的编码可能会记录到日志中，但是不会引起错误。

微服务必须避免错误在系统之间进行层级传递。需要设计某种策略处理API的变更引起的变化。分离模式，例如熔断和隔板。


## 自动化的环境（automated environment）

云环境中的微服务架构，创建一个不规则延伸的独立迁移个体。服务之间的交互关系错综复杂。一个高度自动化的应用对于微服务来说至关重要。

微服务通常需要设计一种策略来进行代码构建和部署，例如持续集成和持续部署。

自动化监控和告警也很重要，虽然独立的服务应该尽可能少的考虑如何管理自己的日志数据，但是他们应该确保合适的日志数据和指标数据能促进自动化的问题检测和告警。


## 微服务和团队结构

微服务架构和团队组织之间的关系具有一定哲理性。微服务的结构要与人员组织结构一致。根据康威定律（Conway's law），任何组织所设计的系统，将不可避免的与组织结构一致。
# 1 创建微服务

## 1.1 定义服务

### 采用领域驱动设计原则

在领域驱动设计中，一个domain表示一个特定的知识领域或活动。一个model代表领域某个重要方面的抽象，用于理解领域的变化。这个模型用于构建解决方案，跨团队交流。

Bounded Context允许领域被分为多个独立的子系统。每个Bounded Context可以拥有自己的模型来表示Domain中的概念。

### 将领域元素转换为服务

### 应用和服务结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181243437.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单体架构，通常将应用分为客户端、Web、业务层、数据层，微服务架构也采用类似的方式进行划分，但是每层的元素由独立的服务提供，并且运行在独立的进程中，如上图2所示。

- BFF（backend for frontend）用于支持特定的前端特定的行为，例如优化设备或提供Web应用额外的能力
- 每个服务拥有和维护各自的数据存储层，数据存储也是独立的服务

然而，不是所有的微服务应用都需要BFF层，例如使用JSP或JSF等与前端Javascript相关的应用，可以看做是BFF层。而单页面应用，是一些静态资源，来自独立的服务，它们运行在浏览器中，直接调用后台API，这种方式是不需要BFF的。


**微服务内部结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181152474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

微服务架构中每个服务的内部情况，如上图所示。调用外部服务应该与领域逻辑进行分离，也应该与后台数据服务进行分离。

图中包括以下几个元素：
- Resources 向外部客户端提供资源，这层对请求进行基本的验证，然后将信息传递到Domain逻辑层
- Domain logic，领域逻辑层，一般有很多形式。在Boundary-Entity-Control模式中，领域逻辑表示entity，参数校验，状态变化逻辑等
- Repository （可选），用于提供核心Domain Logic与数据存储之间的抽象。这个配置允许后台数据存储层的改变或替换不会影响Domain Logic层
-Service connectors 类似于Repository 抽象，封装了与其他服务之间的通讯。这层的功能是作为门面，保护Domain logic不会受外部资源API改变而产生影响。也提供API 格式向内部Domain model结构转换功能。

这个架构要求我们在创建类Classes时，需要遵守一些规则，例如每个用于实现服务的class需要执行至少一项任务：
1.执行Domain Logic
2.显示Resources
3.调用其他服务
4.调用数据存储层

一般而言，建议代码结构不需要严格按照上述进行创建。最重要的是，减少变化带来的风险。例如，如果我们需要改变数据存储（data store），我们可能需要更新Repository层。我们不需要搜索所有的类，来找到那些方法调用了数据存储层。如果外部API服务发生变化，我们可以通过改变service connector中来进行调整。




### 共享库或新建服务

根据DRY（Don't repeat yourself）原则，重复的代码最好封装成公共的方法或库。在微服务架构中，由于服务是相互隔离的进程，这使得获取共享代码实现变得很困难，因而，如何处理共用的代码呢？

1. 接受微服务架构中存在冗余的代码
2. 将共用代码封装成共享的、版本控制的代码库
3. 新建独立的服务

根据代码的本质，最好接受冗余的代码，因为，这样可以保持每个服务的独立演进，便于后续服务的更新这部分初始化共用的代码。

虽然将Data Transfer Objects创建为共享的库比较方便，并且这些DTO也是简单的类，通常用于生成JSON格式，但是这样会丢失对DTO实现细节，并且会增加耦合性。

客户端库最好避免代码冗余，最好让客户端库容易消费APIs。这个技术在数据存储中使用比较常见，包括NoSQL数据存储，提供基于REST的APIs。客户端库同样能为其他服务使用，特别是一些使用二进制的协议。然而，客户端库会引入服务消费与提供者的耦合性。这个服务可能会很难被平台消费，或者很难被没有库支持的语言消费。

共享库也可以用于确保复杂算法过程的一致性，

什么时候讲共享库创建为独立的服务呢？一个独立的服务，可以使用独立的语言开发，可以进行分离的扩展，可以快速的更新服务而不需要同步更新消费者。一个独立的服务也可以添加扩展的进程，从属于服务之间交流。

## 1.2 创建RESTAPIs

如何设计微服务的API呢? 在微服务架构中设计有效和可用的API至关重要，API需要提供文档说明，版本控制，便于消费者理解和使用这些API。

### 从上到下或从下到上

API的设计有两种思路，一种是先设计API然后开展代码实现，一种是先实现服务然后提取API。原则上，第一种方式较好。微服务不是独立进行操作的，服务可能调用其他的服务也可能被其他服务调用。服务之间的调用需要提交定义清除，并且形成文档。


### API 文档

使用工具生成APIs说明文档，规范的API文档有利于精确和正确的使用这些API，也可以用于和API消费者讨论API。这些文档也可以用于消费者驱动的测试。

[Open API Initiative](https://www.openapis.org/) （OAI）是一个标准化RESTful APIs描述的组织。OpenAPI 说明是基于Swagger的，它定义了表示RESTful API结构和元数据格式的创建方法。这中定义由一个可移动的文件描述（swagger.json，也有swagger.yml）。可以使用可视化编辑器或注解的方式在应用中定义swagger。在后续开发中，可以用于生成客户端和server stubs。



### 使用正确的HTTP动词

REST APIs应该使用标准的HTTP方法来表示创建、查询、更新、删除和操作，以及幂等操作。

- POST   表示资源的创建，POST不是幂等操作。例如，多次发起POST请求，每个请求会生成唯一的资源
- GET     表示查询资源，是幂等性操作，多次请求不会产生副作用。GET请求的查询参数不应该用于改变或更新信息。
- PUT     表示更新资源，PUT操作是幂等性的，PUT 操作的请求体，通常包含整个需要更新的资源信息。
- PATCH 表示更新部分资源，根据业务情况可以是幂等操作也可以不是。例如，如果一个PATCH操作，表示一个数值需要从A变到B，这种是幂等操作。多次请求也不会产生其他影响，当数值已经改成B了。
- DELETE 表示删除资源，删除操作是幂等性的，资源只能删除一次。第一次调用时。响应码为200表示操作成功，后续再调用时，响应码为204表示资源未找到。

### 创建机器友好、可描述的结果

一个具有表现力的REST API应用谨慎的考虑返回的结果。由于API的调用一般是使用软件而不是用户，因此，需要与注意调用者的交流尽可能的有效和高效。

例如，比较常见的实践，当我们使用200返回码来HTML解释错误信息。虽然，技术上没有什么问题，用户可以看到错误的页面信息，但是对于机器来说，会认为这次请求成功了。

HTTP状态码应该是有用的并且有相关性的。当操作正常时使用200（OK）。当没有内容返回时，使用204（NO CONTENT）。201（CREATED）应该用于POST请求，表明创建资源的结果，无论是否有响应体。当并发更新冲突时使用409（CONFLICT），当请求参数类型不正确时使用400（BAD REQUEST）。

### 资源URI和版本

RESTful 资源 URI有很多可选的地方。一般而言，资源应该以名词进行描述，而不是动词，节点应该以复数的形式表示。例如：


| URI  | 说明  |
| --- | --- |
| POST /accounts | Create a new item |
| GET /accounts   | Retrieve a list of items |
| GET /accounts/16 | Retrieve a specific item |
| PUT /accounts/16 | Update a specific item |
| PATCH /accounts/16 | Update a specific item |
| DELETE /accounts/16 | Delete a specific item |

URI可以是层级嵌套的方式组织

**版本控制**

微服务最大的好处是，每个服务都可以独立开发演进。服务之间的调用保持独立的前提是，这些API不能轻易更改。

稳健性原则，服务作为发送方要保守一些，作为接收方可以随意一些，在API改变之前一直要保持这种原则。当仍然需要修改API时，可以选择构建一个不同的整个服务，并逐渐替换原始的服务，也许领域模型的演进和更好的抽象能让这件事情更有意义。

如果不需要改变现有的API服务，那么如何管理这些改变呢：
- 服务是否处理所有版本的API？
- 是否需要维护服务的版本来支持多个版本的API？
- 服务是否只支持最新版的API，并且依赖其他的适配层来转换和来自旧版的API？

我们很难抉择，最本质的问题是，我们如何映射API的版本。这有三种方式来处理REST资源的版本：
- 在URI中设置版本
- 使用自定义的版本请求头
- 将版本设置在HTTP的Accept请求头，并依赖内容协调

**URI中添加版本信息** 
这种是最简单的方法来指定版本，有以下几个优点：
- 容易理解
- 容易实现
- 容易使用API浏览工具（例如 Swagger） 和 命令行工具（例如 curl）

如果决定采用URI中版本进行控制，那么版本号需要设置到整个应用上，例如 `api/v1/accounts` ，而不是`api/accounts/v1` .

如果决定使用URI中版本，我们可以采用不同的方式进行管理，部分取决于请求在系统中如何路由。

当然也有反对这种版本控制方式，URL是HTML标准中一个严格解释的，一条URL应该代表一个实体并且如果实体不改变，那么URL也不改变。

其他也指出，将版本放到URI中需要消费者更新他们的URI引用。这种问题可以通过将旧版URI映射到新的请求中，然而，当最新的版本改变时，这样的方法会出现异常行为。

**添加自定义的请求头**

我们也可以添加自定义的请求头来指明API的版本。自定义的请求头可以被路由器或其他基础设施来路由到特定的后台实例。然而，这种机制不容易使用。此外，这种自定义的头只能在我们自己的应用中使用，也就是消费者需要学习如何使用。

**修改Accept Header添加版本**

Accept Header是一个比较明显的地方用于定义版本，但是很难测试。URIs 很容易指定并替换，但是指定HTTPHeader需要更多API的信息以及命令行调用。

设计API时，有以下几点建议：
1.从消费者的角度设计APIs
2.考虑API改变的策略
3.在整个应用中使用一致的版本控制技术

# 3 服务注册与发现

微服务被设计成能够容易水平扩展，需要一种方法来解决多个服务实例如何定位，并且对多个服务的调用如何负载均衡。服务定位包括以下三个部分内容：
1.服务注册
2.服务调用
3.API网关

## 服务注册

服务注册是一个持久化的存储，用于记录当前可用的微服务列表，以及访问他们的路由信息。微服务之间通信需要注册服务，主要因为以下几个原因：
1.注册
当一个服务成功的部署后，微服务需要通过服务注册进行注册
2.心跳
微服务应该发送规律的心跳信息，到注册中心，用于表明当前微服务是正常工作，可以接受请求。
3.服务发现
为了调用其他服务，微服务需要调用注册中心获取可用的服务实例
4.注销
当一个服务关闭后，需要从注册列表中移除该服务。

### 第三方注册 VS 自注册

注册微服务可以在服务中实现也可以使用第三方注册服务。使用第三方注册服务，要求微服务准确测定当前状态并将信息传给注册服务。第三方注册服务也可以注销微服务。如果微服务自己执行注册和心跳检测，注册服务可以取消注册，如果发现心跳丢失。

使用第三方注册服务的优势是，可以将注册和心跳检测的逻辑与业务逻辑分离。缺点是软件需要部署额外的部分，微服务也需要提供健康端点给第三方注册服务使用。

自注册（self-registration）将注册和心跳检测逻辑写入到微服务自身中，这种方式需要小心处理代码测试。然而，很多服务注册解决方案提供一种方便的库用于服务注册，来降低编码的复杂度。

服务发现与注册方案

Consul

Eureka

这些都是开源的服务注册工具，Eureka是Netfli公司的技术，能很容易和其他解决方案进行集成，并且提供负载均衡和容错。


### 可用性 vs 一致性

大部分服务注册中心提供分区容忍，一致性或可用性。他们不可能同时满足CAP理论中三个条件。Eureka提供可用性，Consul和Apache Zookeeper提供一致性。如果我们应用需要在某一个能看到相同的视图，那么选用一致性的服务注册方案；如果需要很快的获得请求的答复，而不需要等待结果的一致性，可以选用可用性的方案。

## 服务调用

当服务需要与其他服务进行通信时，它需要使用存储到服务注册中心的信息。然后，通过服务端或客户端调用实际的微服务。

### 服务端

通过服务代理实现服务端通信，Service Proxy作为服务注册中心的一部分，或者独立的服务。当服务需要调用其他服务时，首先调用代理服务端点。这个代理服务会返回从服务注册中心获取的目标服务的地址。代理器将获取的结果和路由返回给原服务，提供给原服务用于发起请求。负载均衡完全在服务端处理。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180516410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

使用Server-side调用有以下几个优势：
1.请求简单
请求会很简单，因为微服务调用一个已知的终端。
2.容易测试
使用服务代理将负载均衡或路由逻辑从微服务中剥离，这样可以使用Mocked代理测试服务的所有功能。

然而，这种方式也存在缺陷

1.路由跳转过多
新增的服务代理，增加了网络请求的次数。这方式比客户端方案需要调用的次数更多。而用代理服务次缓存请求是没有价值的，很多情景，请求会走1->4->5->6

### 客户端（Client side）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180538417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)


微服务之间的调用也可以直接使用客户端调用。服务注册返回微服务一个或多个实例的地址；然后，由客户端向该地址发出请求。微服务的地址通常会被缓存起来，这样在后续的调用中可以直接访问实际的地址，而不需要向注册服务查询。如果直接访问实际地址失败，客户端将重复第一次操作，向注册服务获取信息。最好对服务地址的缓存设置超时，这样当新版的服务部署后，其他服务不会访问缓存中错误的地址，而访问新的实例。

发起这些请求，以及负载均衡可以使用以下两种方式实现：
1.客户端库（Client library）
2.边车（sidecar）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180550360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

两种方式都可以在客户端发起请求。然而，客户端库与微服务是一个整体，一起运行的；而边车（sidecar）是与微服务部署在一起的，可以运行在独立的进程。

**client library**
客户端库的方式很有效，将与其他远程资源通信的逻辑独立开。对于服务注册中心，client libraris可以是 Consul 或 Netflix Eureka 用于处理服务注册和心跳检测。其他的库，例如Netflix Ribbon，提供客户端的负载均衡。

一般而言，选用一个现有的库而不是自己写。如果所有的微服务使用Java编写，那边我们需要标准化这个库。如果我们有一个微服务系统，最好每个微服务使用相同的库进行请求调用，这样开发者从一个服务向另一个服务过渡不会增加基础设施和构建进程的复杂性。

这种方式的弊端是，我们将复杂的服务调用融入到了服务中，这样测试服务会变得很复杂，需要很好的区分使用了client library的代码和业务逻辑代码。

**sidecar**
另个比较好的方案是使用边车模式，边车是一个与微服务部署在一起的分离进程，或者一个分离的容器进程，或相关联的分离的容器。

边车调用服务注册中心获取服务注册信息，并保存这些信息，也具有客户端的负载均衡能力，来调用其他服务。

由于边车运行在自己的进程中，他可以使用独立的语言开发。在所有微服务中可以使用相同边车实现，而不需要管微服务使用何种语言。

[Netflix Prana](http://github.com/Netflix/Prana)是一个开源的边车组件用于提供Ribbon和Eureka客户端的能力。

[Kubernates](http://kubernetes.io/docs/user-guide/services)是一个容器编排引擎，提供服务发现和负载均衡能力的sidecar。


## API网关

API 网关（API Gateway）能够执行内部或外部客户端的服务的调用。API Gateway与服务代理的角色很像。服务向API网关发送请求，而服务网关向服务注册中心获取服务地址，然后根据地址发起请求，将请求后的结果返回给调用者。与代理服务器不同的是，API网关可以提供不同与原微服务提供的API。

内部的微服务可以使用确切的APIs，同时API网关提供外部客户端调用。一般来说，微服务提供细粒度的APIs，而外部客户端通常不需要那么细粒度的API，这时API网关可以屏蔽内部一些API，向外部客户端提供有用的API。所有的外部客户端通过API网关访问应用。

# 4 微服务间通信

在分布式系统中，服务内部的通信很重要的。组成应用的微服务需要一起无缝的工作，向客户端提供服务。不同服务之间的通信有两种形式，同步和异步调用。

## 4.1 同步和异步

同步通信，即请求后立马获得响应。异步通信，是一种消息，不需要响应。

高度分布式系统中使用异步事件或消息就是强有力的应用场景。

对于任何一种调用风格，开放的API需要提供文档说明。事件或消息负载也需要提供文档说明。事件订阅者或API消费者应该容忍不识别的字段，它们可能是新的。服务应该抛出异常和处理错误数据。

### 同步信息（REST）

在分布式系统中，异步形式的消息是很有价值的。当应用清晰的请求和响应语义，或一个服务需要与另一个服务紧密关联行为，应该使用异步API。

很多RESTful 操作能解析JSON格式的数据，当让其他协议或格式的数据也可以。基于Java的微服务最好使用JSON数据格式。



### 异步信息（Event）

异步消息能够解耦服务。一个异步事件能够使用，如果事件创造者不需要响应信息。

一个来自外部客户端的请求在获取响应信息前可能会穿过多个微服务。如果每个调用都是同步的，那么整个时间会阻断其他请求。微服务系统越复杂，那么微服务之间的交互需要额外的请求，将导致系统延时更长。如果请求的进程可以被异步事件替代，那么可以用事件来取代。

使用响应式的事件，一个服务应该发布自己状态或活动的事件。其他服务可以订阅这些事件并协同响应。

事件是很好的方式组建新的交互模式，而不需要引入依赖。这种使得框架具有扩展性，不需要再服务创建的时候考虑，后续可以扩展。

微服务风格的架构需要每个微服务拥有自己的数据。这意味着当请求进来时，可能有好几个服务需要更新自己的数据库。服务应该使用事件来通知数据变化，其他模块可以订阅这些事件。

为了协调应用中的消息，我们可以使用任何一个可用的消息代理方案。例如AMQP、RabbitMQ、Apache Kafka， MQTT等。

## 4.2 容错

我们选用微服务架构，一个很重要的动机是微服务架构可以创建容错和弹性伸缩的应用。现代应用被要求具有接近零的停机时间，秒级以内的响应。微服务架构中每个独立的服务必须能持续工作，即便其他的服务已经宕机。这就要就微服务应用在设计时具有容错的能力。

### 弹性可变

当使用同步请求调用其他微服务时，我们使用的是具体API，API被事先定义了输入属性，以及输出属性。微服务环境中，这种API的请求和响应数据一般采用JSON格式。现实中，我们很难保证输入和输出的属性不发生更改。基本是最佳的应用设计实践，需求也是经常改变的，这会造成属性的增加、删除或改变。为了弹性的应对这些变化，微服务的设计者需要考虑到API的消费和生成。

**APIs 消费**
作为API的消费者，我们需要校验调用API后获取的响应数据，判断它是否包含我们功能执行所需的信息。如果获取JSON格式的数据，我们需要解析JSON数据，在执行其他转换之前。当我们校验JSON或解析JSON时，我们必须做两件事情：

1.只校验请求中需要使用的变量或熟悉
不需要校验请求提供的所有变量。如果我们使用这些请求中的参数，我们不需要它们。
2.接受未知的属性
不需要提交异常，如果我们接收到异常的变量。如果响应体共包含我们所需的信息，那么不用在意其他额外的属性。

选择JSON解析工具允许我们配置如何解析进来的数据。例如Jackson提供@JsonInclude和@JsonIgnoreProperties注解的方式解析数据。

遵从这两天规则，我们的微服务可以变得更加弹性来应对任何改变，而不会受到直接影响。基本微服务添加或移除我们并未使用的属性，微服务仍然正常工作。

**APIs 生成**

当提供外部客户端调用的API时，请求和响应中有两件事需要考虑：
1.接收未知的请求属性
如果一个服务调用API，请求中包括不需要的参数，那么服务可以丢弃这些参数值。只有引起不需要的失败时才返回错误信息。
2.只返回API调用相关的属性
留尽可能多的空间来实现服务后续的改变。避免分享的过程中泄露实现细节。

遵从这两条可以让服务更加稳健。


### 超时（Timeouts）

当请求其他微服务时，无论同步请求或异步请求，请求必须设置超时参数。因为，我们希望用完服务就走，而不应该等待不确定的响应。

异步请求可以设置超时参数，例如 Failsafe和 Netflix Hystrix内置了超时设置。

设置超时可以提升微服务的弹性，但是仍然会导致不好的用户体验，因为端到端的调用会变慢。如果可以的话将超时设置一致，那么服务A向服务B请求超时，同时服务B等待服务C。

### 熔断（Circuit Breakers）

使用超时保护请求，避免等待不确定的响应。然而，如果某个请求经常发生超时，这会浪费很多时间等待超时发生。

熔断（Circuit Breaker）是一种用来避免重复超时发生的技术。这种技术类似电路里面的保险丝。熔断会记录每个调用失败或超时的请求。如果这些请求次数总和达到了一定的阈值，它会阻断后续请求的调用，直接返回错误信息。它也提供一种机制来重新尝试请求，尝试几次或根据响应某个事件。

熔断对于调用外界服务至关重要，一般来说，使用现在的熔断库即可实现此功能。

### 隔板（Bulkheads）

在轮船中，隔板用来隔离船舱避免因一个船舱漏水造成整个船沉掉。微服务中的隔板（Bulkheads）类似轮船中的隔板概念。我们需要避免微服务中某个部分的失败不会对整个微服务系统造成影响。隔板模式就是关于如何创建微服务而不是使用某个特定工具或库。当我们创建微服务时，我们总是告诫自己如何分离不同的模块，并且避免滚雪球式的崩溃。

实现隔板模式最简单的方式是提供回退（fallbacks）。添加fallback运行应用继续工作，当非重重要的服务宕机时。例如，一个在线的零售店系统，其中一个服务提供用户推荐信息，如果推荐服务宕机了，那么用户仍然可以查询商品和下单。一个有趣的回退链例子，当调用个性内容失败时，回退成调用更加一般的内容，这将回退成返回缓存内容，而不是返回错误。

另一种策略，为了避免慢的或勉强的远程资源造成整个系统宕机，可以使用受限可用的资源来应对这些超出的请求，最常见的方式使用队列（queue），以及 [信号量（semaphore）](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html) 

**队列**
队列有一个大小设置，当请求添加到已满的队列时，该请求会直接抛错。队列会生成有限数量的worker，每个定义了服务最大的线程数，可以被远程资源阻塞。

**信号量（semaphore）**
semaphore机制工作原理，是提供多个permits，向远端发起请求是需要一个permit，当请求完成后会释放permit。

队列和信号量最显著的区别是在资源用尽时的处理不同，使用Semaphore方法，超出的请求会直接被跳过，如果不能获取到permit； 而队列的方式，请求会等待（除非队列满了，请求会被丢弃）。










