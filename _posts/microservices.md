# 微服务简介(MicroService)

微服务是一种架构风格，一个或多个小的微服务组成一个复杂、庞大的软件应用。每个微服务集中在完成一个较小业务能力的任务。这些微服务可以用任意语言开发。

Martin Fowler’s 定义的微服务，微服务用于组成复杂的应用，微服务够小，独立、进程可替代、微服务之间使用轻量级的API， 并且微服务不依赖统一的开发语言

更多信息参考：Martin Fowler的论文“Microservices: A new architectural term”, http://martinfowler.com/articles/microservices.html


## 微服务多小才算小

微服务大小不是由代码行数决定的，微服务足够小，聚焦在特定目的。微服务应用做一件事情，并且做好这件事情。

## 独立和自治（independence and autonomy）

为了确保每个服务在创建、维护时保持敏捷性，每个服务应该独立和自治。每个服务能够在任何时间启动、停止、替换，不会紧密与其他服务绑定。微服务其他要素遵循这一点。

微服务架构风格应该扮演一个包装来守护应用的具体实现细节。这种配置允许服务的实现，以后可被修订并且提升（甚至重写）。特别是数据源必须是服务私有的。

## 弹性和容错（resilience and fault tolerance）

服务需要具有弹性的能力，也就是说在动态的云环境中，服务需要预测和平缓地响应异常，即当服务接收到错误的数据时，不会影响到后台服务（Backing Service），或者处理分布式系统中并发更新的冲突。

独立演进但是相互之间存在依赖关系的服务，鲁棒性原则提供最佳指导：“对接收的可以进行自由操作，对于发出的需要谨慎处理”。  假设API会逐渐演进，对于无法理解的数据能够容错，引用RFC：
    简单举例，一个协议包含多个枚举值，这些枚举类一定是不完整的。因此，如果协议定义了4个可能的错误码，当服务接收到第5个错误码时，服务不会宕机。无法识别的编码可能会记录到日志中，但是不会引起错误。

微服务必须避免错误在系统之间进行层级传递。需要设计某种策略处理API的变更引起的变化。分离模式，例如熔断和隔板。


## 自动化的环境（automated environment）

云环境中的微服务架构，创建一个不规则延伸的独立迁移个体。服务之间的交互关系错综复杂。一个高度自动化的应用对于微服务来说至关重要。

微服务通常需要设计一种策略来进行代码构建和部署，例如持续集成和持续部署。

自动化监控和告警也很重要，虽然独立的服务应该尽可能少的考虑如何管理自己的日志数据，但是他们应该确保合适的日志数据和指标数据能促进自动化的问题检测和告警。


## 微服务和团队结构

微服务架构和团队组织之间的关系具有一定哲理性。微服务的结构要与人员组织结构一致。根据康威定律（Conway's law），任何组织所设计的系统，将不可避免的与组织结构一致。
# 1 创建微服务

## 1.1 定义服务

### 采用领域驱动设计原则

在领域驱动设计中，一个domain表示一个特定的知识领域或活动。一个model代表领域某个重要方面的抽象，用于理解领域的变化。这个模型用于构建解决方案，跨团队交流。

Bounded Context允许领域被分为多个独立的子系统。每个Bounded Context可以拥有自己的模型来表示Domain中的概念。

### 将领域元素转换为服务

### 应用和服务结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181243437.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单体架构，通常将应用分为客户端、Web、业务层、数据层，微服务架构也采用类似的方式进行划分，但是每层的元素由独立的服务提供，并且运行在独立的进程中，如上图2所示。

- BFF（backend for frontend）用于支持特定的前端特定的行为，例如优化设备或提供Web应用额外的能力
- 每个服务拥有和维护各自的数据存储层，数据存储也是独立的服务

然而，不是所有的微服务应用都需要BFF层，例如使用JSP或JSF等与前端Javascript相关的应用，可以看做是BFF层。而单页面应用，是一些静态资源，来自独立的服务，它们运行在浏览器中，直接调用后台API，这种方式是不需要BFF的。


**微服务内部结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181152474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

微服务架构中每个服务的内部情况，如上图所示。调用外部服务应该与领域逻辑进行分离，也应该与后台数据服务进行分离。

图中包括以下几个元素：
- Resources 向外部客户端提供资源，这层对请求进行基本的验证，然后将信息传递到Domain逻辑层
- Domain logic，领域逻辑层，一般有很多形式。在Boundary-Entity-Control模式中，领域逻辑表示entity，参数校验，状态变化逻辑等
- Repository （可选），用于提供核心Domain Logic与数据存储之间的抽象。这个配置允许后台数据存储层的改变或替换不会影响Domain Logic层
-Service connectors 类似于Repository 抽象，封装了与其他服务之间的通讯。这层的功能是作为门面，保护Domain logic不会受外部资源API改变而产生影响。也提供API 格式向内部Domain model结构转换功能。

这个架构要求我们在创建类Classes时，需要遵守一些规则，例如每个用于实现服务的class需要执行至少一项任务：
1.执行Domain Logic
2.显示Resources
3.调用其他服务
4.调用数据存储层

一般而言，建议代码结构不需要严格按照上述进行创建。最重要的是，减少变化带来的风险。例如，如果我们需要改变数据存储（data store），我们可能需要更新Repository层。我们不需要搜索所有的类，来找到那些方法调用了数据存储层。如果外部API服务发生变化，我们可以通过改变service connector中来进行调整。




### 共享库或新建服务

根据DRY（Don't repeat yourself）原则，重复的代码最好封装成公共的方法或库。在微服务架构中，由于服务是相互隔离的进程，这使得获取共享代码实现变得很困难，因而，如何处理共用的代码呢？

1. 接受微服务架构中存在冗余的代码
2. 将共用代码封装成共享的、版本控制的代码库
3. 新建独立的服务

根据代码的本质，最好接受冗余的代码，因为，这样可以保持每个服务的独立演进，便于后续服务的更新这部分初始化共用的代码。

虽然将Data Transfer Objects创建为共享的库比较方便，并且这些DTO也是简单的类，通常用于生成JSON格式，但是这样会丢失对DTO实现细节，并且会增加耦合性。

客户端库最好避免代码冗余，最好让客户端库容易消费APIs。这个技术在数据存储中使用比较常见，包括NoSQL数据存储，提供基于REST的APIs。客户端库同样能为其他服务使用，特别是一些使用二进制的协议。然而，客户端库会引入服务消费与提供者的耦合性。这个服务可能会很难被平台消费，或者很难被没有库支持的语言消费。

共享库也可以用于确保复杂算法过程的一致性，

什么时候讲共享库创建为独立的服务呢？一个独立的服务，可以使用独立的语言开发，可以进行分离的扩展，可以快速的更新服务而不需要同步更新消费者。一个独立的服务也可以添加扩展的进程，从属于服务之间交流。

## 1.2 创建RESTAPIs

如何设计微服务的API呢? 在微服务架构中设计有效和可用的API至关重要，API需要提供文档说明，版本控制，便于消费者理解和使用这些API。

### 从上到下或从下到上

API的设计有两种思路，一种是先设计API然后开展代码实现，一种是先实现服务然后提取API。原则上，第一种方式较好。微服务不是独立进行操作的，服务可能调用其他的服务也可能被其他服务调用。服务之间的调用需要提交定义清除，并且形成文档。


### API 文档

使用工具生成APIs说明文档，规范的API文档有利于精确和正确的使用这些API，也可以用于和API消费者讨论API。这些文档也可以用于消费者驱动的测试。

[Open API Initiative](https://www.openapis.org/) （OAI）是一个标准化RESTful APIs描述的组织。OpenAPI 说明是基于Swagger的，它定义了表示RESTful API结构和元数据格式的创建方法。这中定义由一个可移动的文件描述（swagger.json，也有swagger.yml）。可以使用可视化编辑器或注解的方式在应用中定义swagger。在后续开发中，可以用于生成客户端和server stubs。



### 使用正确的HTTP动词

REST APIs应该使用标准的HTTP方法来表示创建、查询、更新、删除和操作，以及幂等操作。

- POST   表示资源的创建，POST不是幂等操作。例如，多次发起POST请求，每个请求会生成唯一的资源
- GET     表示查询资源，是幂等性操作，多次请求不会产生副作用。GET请求的查询参数不应该用于改变或更新信息。
- PUT     表示更新资源，PUT操作是幂等性的，PUT 操作的请求体，通常包含整个需要更新的资源信息。
- PATCH 表示更新部分资源，根据业务情况可以是幂等操作也可以不是。例如，如果一个PATCH操作，表示一个数值需要从A变到B，这种是幂等操作。多次请求也不会产生其他影响，当数值已经改成B了。
- DELETE 表示删除资源，删除操作是幂等性的，资源只能删除一次。第一次调用时。响应码为200表示操作成功，后续再调用时，响应码为204表示资源未找到。

### 创建机器友好、可描述的结果

一个具有表现力的REST API应用谨慎的考虑返回的结果。由于API的调用一般是使用软件而不是用户，因此，需要与注意调用者的交流尽可能的有效和高效。

例如，比较常见的实践，当我们使用200返回码来HTML解释错误信息。虽然，技术上没有什么问题，用户可以看到错误的页面信息，但是对于机器来说，会认为这次请求成功了。

HTTP状态码应该是有用的并且有相关性的。当操作正常时使用200（OK）。当没有内容返回时，使用204（NO CONTENT）。201（CREATED）应该用于POST请求，表明创建资源的结果，无论是否有响应体。当并发更新冲突时使用409（CONFLICT），当请求参数类型不正确时使用400（BAD REQUEST）。

### 资源URI和版本

RESTful 资源 URI有很多可选的地方。一般而言，资源应该以名词进行描述，而不是动词，节点应该以复数的形式表示。例如：


| URI  | 说明  |
| --- | --- |
| POST /accounts | Create a new item |
| GET /accounts   | Retrieve a list of items |
| GET /accounts/16 | Retrieve a specific item |
| PUT /accounts/16 | Update a specific item |
| PATCH /accounts/16 | Update a specific item |
| DELETE /accounts/16 | Delete a specific item |

URI可以是层级嵌套的方式组织

**版本控制**

微服务最大的好处是，每个服务都可以独立开发演进。服务之间的调用保持独立的前提是，这些API不能轻易更改。

稳健性原则，服务作为发送方要保守一些，作为接收方可以随意一些，在API改变之前一直要保持这种原则。当仍然需要修改API时，可以选择构建一个不同的整个服务，并逐渐替换原始的服务，也许领域模型的演进和更好的抽象能让这件事情更有意义。

如果不需要改变现有的API服务，那么如何管理这些改变呢：
- 服务是否处理所有版本的API？
- 是否需要维护服务的版本来支持多个版本的API？
- 服务是否只支持最新版的API，并且依赖其他的适配层来转换和来自旧版的API？

我们很难抉择，最本质的问题是，我们如何映射API的版本。这有三种方式来处理REST资源的版本：
- 在URI中设置版本
- 使用自定义的版本请求头
- 将版本设置在HTTP的Accept请求头，并依赖内容协调

**URI中添加版本信息** 
这种是最简单的方法来指定版本，有以下几个优点：
- 容易理解
- 容易实现
- 容易使用API浏览工具（例如 Swagger） 和 命令行工具（例如 curl）

如果决定采用URI中版本进行控制，那么版本号需要设置到整个应用上，例如 `api/v1/accounts` ，而不是`api/accounts/v1` .

如果决定使用URI中版本，我们可以采用不同的方式进行管理，部分取决于请求在系统中如何路由。

当然也有反对这种版本控制方式，URL是HTML标准中一个严格解释的，一条URL应该代表一个实体并且如果实体不改变，那么URL也不改变。

其他也指出，将版本放到URI中需要消费者更新他们的URI引用。这种问题可以通过将旧版URI映射到新的请求中，然而，当最新的版本改变时，这样的方法会出现异常行为。

**添加自定义的请求头**

我们也可以添加自定义的请求头来指明API的版本。自定义的请求头可以被路由器或其他基础设施来路由到特定的后台实例。然而，这种机制不容易使用。此外，这种自定义的头只能在我们自己的应用中使用，也就是消费者需要学习如何使用。

**修改Accept Header添加版本**

Accept Header是一个比较明显的地方用于定义版本，但是很难测试。URIs 很容易指定并替换，但是指定HTTPHeader需要更多API的信息以及命令行调用。

设计API时，有以下几点建议：
1.从消费者的角度设计APIs
2.考虑API改变的策略
3.在整个应用中使用一致的版本控制技术

# 3 服务注册与发现

微服务被设计成能够容易水平扩展，需要一种方法来解决多个服务实例如何定位，并且对多个服务的调用如何负载均衡。服务定位包括以下三个部分内容：
1.服务注册
2.服务调用
3.API网关

## 服务注册

服务注册是一个持久化的存储，用于记录当前可用的微服务列表，以及访问他们的路由信息。微服务之间通信需要注册服务，主要因为以下几个原因：
1.注册
当一个服务成功的部署后，微服务需要通过服务注册进行注册
2.心跳
微服务应该发送规律的心跳信息，到注册中心，用于表明当前微服务是正常工作，可以接受请求。
3.服务发现
为了调用其他服务，微服务需要调用注册中心获取可用的服务实例
4.注销
当一个服务关闭后，需要从注册列表中移除该服务。

### 第三方注册 VS 自注册

注册微服务可以在服务中实现也可以使用第三方注册服务。使用第三方注册服务，要求微服务准确测定当前状态并将信息传给注册服务。第三方注册服务也可以注销微服务。如果微服务自己执行注册和心跳检测，注册服务可以取消注册，如果发现心跳丢失。

使用第三方注册服务的优势是，可以将注册和心跳检测的逻辑与业务逻辑分离。缺点是软件需要部署额外的部分，微服务也需要提供健康端点给第三方注册服务使用。

自注册（self-registration）将注册和心跳检测逻辑写入到微服务自身中，这种方式需要小心处理代码测试。然而，很多服务注册解决方案提供一种方便的库用于服务注册，来降低编码的复杂度。

服务发现与注册方案

Consul

Eureka

这些都是开源的服务注册工具，Eureka是Netfli公司的技术，能很容易和其他解决方案进行集成，并且提供负载均衡和容错。


### 可用性 vs 一致性

大部分服务注册中心提供分区容忍，一致性或可用性。他们不可能同时满足CAP理论中三个条件。Eureka提供可用性，Consul和Apache Zookeeper提供一致性。如果我们应用需要在某一个能看到相同的视图，那么选用一致性的服务注册方案；如果需要很快的获得请求的答复，而不需要等待结果的一致性，可以选用可用性的方案。

## 服务调用

当服务需要与其他服务进行通信时，它需要使用存储到服务注册中心的信息。然后，通过服务端或客户端调用实际的微服务。

### 服务端

通过服务代理实现服务端通信，Service Proxy作为服务注册中心的一部分，或者独立的服务。当服务需要调用其他服务时，首先调用代理服务端点。这个代理服务会返回从服务注册中心获取的目标服务的地址。代理器将获取的结果和路由返回给原服务，提供给原服务用于发起请求。负载均衡完全在服务端处理。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180516410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

使用Server-side调用有以下几个优势：
1.请求简单
请求会很简单，因为微服务调用一个已知的终端。
2.容易测试
使用服务代理将负载均衡或路由逻辑从微服务中剥离，这样可以使用Mocked代理测试服务的所有功能。

然而，这种方式也存在缺陷

1.路由跳转过多
新增的服务代理，增加了网络请求的次数。这方式比客户端方案需要调用的次数更多。而用代理服务次缓存请求是没有价值的，很多情景，请求会走1->4->5->6

### 客户端（Client side）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180538417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)


微服务之间的调用也可以直接使用客户端调用。服务注册返回微服务一个或多个实例的地址；然后，由客户端向该地址发出请求。微服务的地址通常会被缓存起来，这样在后续的调用中可以直接访问实际的地址，而不需要向注册服务查询。如果直接访问实际地址失败，客户端将重复第一次操作，向注册服务获取信息。最好对服务地址的缓存设置超时，这样当新版的服务部署后，其他服务不会访问缓存中错误的地址，而访问新的实例。

发起这些请求，以及负载均衡可以使用以下两种方式实现：
1.客户端库（Client library）
2.边车（sidecar）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180550360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

两种方式都可以在客户端发起请求。然而，客户端库与微服务是一个整体，一起运行的；而边车（sidecar）是与微服务部署在一起的，可以运行在独立的进程。

**client library**
客户端库的方式很有效，将与其他远程资源通信的逻辑独立开。对于服务注册中心，client libraris可以是 Consul 或 Netflix Eureka 用于处理服务注册和心跳检测。其他的库，例如Netflix Ribbon，提供客户端的负载均衡。

一般而言，选用一个现有的库而不是自己写。如果所有的微服务使用Java编写，那边我们需要标准化这个库。如果我们有一个微服务系统，最好每个微服务使用相同的库进行请求调用，这样开发者从一个服务向另一个服务过渡不会增加基础设施和构建进程的复杂性。

这种方式的弊端是，我们将复杂的服务调用融入到了服务中，这样测试服务会变得很复杂，需要很好的区分使用了client library的代码和业务逻辑代码。

**sidecar**
另个比较好的方案是使用边车模式，边车是一个与微服务部署在一起的分离进程，或者一个分离的容器进程，或相关联的分离的容器。

边车调用服务注册中心获取服务注册信息，并保存这些信息，也具有客户端的负载均衡能力，来调用其他服务。

由于边车运行在自己的进程中，他可以使用独立的语言开发。在所有微服务中可以使用相同边车实现，而不需要管微服务使用何种语言。

[Netflix Prana](http://github.com/Netflix/Prana)是一个开源的边车组件用于提供Ribbon和Eureka客户端的能力。

[Kubernates](http://kubernetes.io/docs/user-guide/services)是一个容器编排引擎，提供服务发现和负载均衡能力的sidecar。


## API网关

API 网关（API Gateway）能够执行内部或外部客户端的服务的调用。API Gateway与服务代理的角色很像。服务向API网关发送请求，而服务网关向服务注册中心获取服务地址，然后根据地址发起请求，将请求后的结果返回给调用者。与代理服务器不同的是，API网关可以提供不同与原微服务提供的API。

内部的微服务可以使用确切的APIs，同时API网关提供外部客户端调用。一般来说，微服务提供细粒度的APIs，而外部客户端通常不需要那么细粒度的API，这时API网关可以屏蔽内部一些API，向外部客户端提供有用的API。所有的外部客户端通过API网关访问应用。



