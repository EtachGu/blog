# 微服务简介(MicroService)

微服务是一种架构风格，一个或多个小的微服务组成一个复杂、庞大的软件应用。每个微服务集中在完成一个较小业务能力的任务。这些微服务可以用任意语言开发。

Martin Fowler’s 定义的微服务，微服务用于组成复杂的应用，微服务够小，独立、进程可替代、微服务之间使用轻量级的API， 并且微服务不依赖统一的开发语言

更多信息参考：Martin Fowler的论文“Microservices: A new architectural term”, http://martinfowler.com/articles/microservices.html


## 微服务多小才算小

微服务大小不是由代码行数决定的，微服务足够小，聚焦在特定目的。微服务应用做一件事情，并且做好这件事情。

## 独立和自治（independence and autonomy）

为了确保每个服务在创建、维护时保持敏捷性，每个服务应该独立和自治。每个服务能够在任何时间启动、停止、替换，不会紧密与其他服务绑定。微服务其他要素遵循这一点。

微服务架构风格应该扮演一个包装来守护应用的具体实现细节。这种配置允许服务的实现，以后可被修订并且提升（甚至重写）。特别是数据源必须是服务私有的。

## 弹性和容错（resilience and fault tolerance）

服务需要具有弹性的能力，也就是说在动态的云环境中，服务需要预测和平缓地响应异常，即当服务接收到错误的数据时，不会影响到后台服务（Backing Service），或者处理分布式系统中并发更新的冲突。

独立演进但是相互之间存在依赖关系的服务，鲁棒性原则提供最佳指导：“对接收的可以进行自由操作，对于发出的需要谨慎处理”。  假设API会逐渐演进，对于无法理解的数据能够容错，引用RFC：
    简单举例，一个协议包含多个枚举值，这些枚举类一定是不完整的。因此，如果协议定义了4个可能的错误码，当服务接收到第5个错误码时，服务不会宕机。无法识别的编码可能会记录到日志中，但是不会引起错误。

微服务必须避免错误在系统之间进行层级传递。需要设计某种策略处理API的变更引起的变化。分离模式，例如熔断和隔板。


## 自动化的环境（automated environment）

云环境中的微服务架构，创建一个不规则延伸的独立迁移个体。服务之间的交互关系错综复杂。一个高度自动化的应用对于微服务来说至关重要。

微服务通常需要设计一种策略来进行代码构建和部署，例如持续集成和持续部署。

自动化监控和告警也很重要，虽然独立的服务应该尽可能少的考虑如何管理自己的日志数据，但是他们应该确保合适的日志数据和指标数据能促进自动化的问题检测和告警。


## 微服务和团队结构

微服务架构和团队组织之间的关系具有一定哲理性。微服务的结构要与人员组织结构一致。根据康威定律（Conway's law），任何组织所设计的系统，将不可避免的与组织结构一致。
# 1 创建微服务

## 1.1 定义服务

### 采用领域驱动设计原则

在领域驱动设计中，一个domain表示一个特定的知识领域或活动。一个model代表领域某个重要方面的抽象，用于理解领域的变化。这个模型用于构建解决方案，跨团队交流。

Bounded Context允许领域被分为多个独立的子系统。每个Bounded Context可以拥有自己的模型来表示Domain中的概念。

### 将领域元素转换为服务

### 应用和服务结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181243437.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单体架构，通常将应用分为客户端、Web、业务层、数据层，微服务架构也采用类似的方式进行划分，但是每层的元素由独立的服务提供，并且运行在独立的进程中，如上图2所示。

- BFF（backend for frontend）用于支持特定的前端特定的行为，例如优化设备或提供Web应用额外的能力
- 每个服务拥有和维护各自的数据存储层，数据存储也是独立的服务

然而，不是所有的微服务应用都需要BFF层，例如使用JSP或JSF等与前端Javascript相关的应用，可以看做是BFF层。而单页面应用，是一些静态资源，来自独立的服务，它们运行在浏览器中，直接调用后台API，这种方式是不需要BFF的。


**微服务内部结构**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426181152474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

微服务架构中每个服务的内部情况，如上图所示。调用外部服务应该与领域逻辑进行分离，也应该与后台数据服务进行分离。

图中包括以下几个元素：
- Resources 向外部客户端提供资源，这层对请求进行基本的验证，然后将信息传递到Domain逻辑层
- Domain logic，领域逻辑层，一般有很多形式。在Boundary-Entity-Control模式中，领域逻辑表示entity，参数校验，状态变化逻辑等
- Repository （可选），用于提供核心Domain Logic与数据存储之间的抽象。这个配置允许后台数据存储层的改变或替换不会影响Domain Logic层
-Service connectors 类似于Repository 抽象，封装了与其他服务之间的通讯。这层的功能是作为门面，保护Domain logic不会受外部资源API改变而产生影响。也提供API 格式向内部Domain model结构转换功能。

这个架构要求我们在创建类Classes时，需要遵守一些规则，例如每个用于实现服务的class需要执行至少一项任务：
1.执行Domain Logic
2.显示Resources
3.调用其他服务
4.调用数据存储层

一般而言，建议代码结构不需要严格按照上述进行创建。最重要的是，减少变化带来的风险。例如，如果我们需要改变数据存储（data store），我们可能需要更新Repository层。我们不需要搜索所有的类，来找到那些方法调用了数据存储层。如果外部API服务发生变化，我们可以通过改变service connector中来进行调整。




### 共享库或新建服务

根据DRY（Don't repeat yourself）原则，重复的代码最好封装成公共的方法或库。在微服务架构中，由于服务是相互隔离的进程，这使得获取共享代码实现变得很困难，因而，如何处理共用的代码呢？

1. 接受微服务架构中存在冗余的代码
2. 将共用代码封装成共享的、版本控制的代码库
3. 新建独立的服务

根据代码的本质，最好接受冗余的代码，因为，这样可以保持每个服务的独立演进，便于后续服务的更新这部分初始化共用的代码。

虽然将Data Transfer Objects创建为共享的库比较方便，并且这些DTO也是简单的类，通常用于生成JSON格式，但是这样会丢失对DTO实现细节，并且会增加耦合性。

客户端库最好避免代码冗余，最好让客户端库容易消费APIs。这个技术在数据存储中使用比较常见，包括NoSQL数据存储，提供基于REST的APIs。客户端库同样能为其他服务使用，特别是一些使用二进制的协议。然而，客户端库会引入服务消费与提供者的耦合性。这个服务可能会很难被平台消费，或者很难被没有库支持的语言消费。

共享库也可以用于确保复杂算法过程的一致性，

什么时候讲共享库创建为独立的服务呢？一个独立的服务，可以使用独立的语言开发，可以进行分离的扩展，可以快速的更新服务而不需要同步更新消费者。一个独立的服务也可以添加扩展的进程，从属于服务之间交流。

## 1.2 创建RESTAPIs

如何设计微服务的API呢? 在微服务架构中设计有效和可用的API至关重要，API需要提供文档说明，版本控制，便于消费者理解和使用这些API。

### 从上到下或从下到上

API的设计有两种思路，一种是先设计API然后开展代码实现，一种是先实现服务然后提取API。原则上，第一种方式较好。微服务不是独立进行操作的，服务可能调用其他的服务也可能被其他服务调用。服务之间的调用需要提交定义清除，并且形成文档。


### API 文档

使用工具生成APIs说明文档，规范的API文档有利于精确和正确的使用这些API，也可以用于和API消费者讨论API。这些文档也可以用于消费者驱动的测试。

[Open API Initiative](https://www.openapis.org/) （OAI）是一个标准化RESTful APIs描述的组织。OpenAPI 说明是基于Swagger的，它定义了表示RESTful API结构和元数据格式的创建方法。这中定义由一个可移动的文件描述（swagger.json，也有swagger.yml）。可以使用可视化编辑器或注解的方式在应用中定义swagger。在后续开发中，可以用于生成客户端和server stubs。



### 使用正确的HTTP动词

REST APIs应该使用标准的HTTP方法来表示创建、查询、更新、删除和操作，以及幂等操作。

- POST   表示资源的创建，POST不是幂等操作。例如，多次发起POST请求，每个请求会生成唯一的资源
- GET     表示查询资源，是幂等性操作，多次请求不会产生副作用。GET请求的查询参数不应该用于改变或更新信息。
- PUT     表示更新资源，PUT操作是幂等性的，PUT 操作的请求体，通常包含整个需要更新的资源信息。
- PATCH 表示更新部分资源，根据业务情况可以是幂等操作也可以不是。例如，如果一个PATCH操作，表示一个数值需要从A变到B，这种是幂等操作。多次请求也不会产生其他影响，当数值已经改成B了。
- DELETE 表示删除资源，删除操作是幂等性的，资源只能删除一次。第一次调用时。响应码为200表示操作成功，后续再调用时，响应码为204表示资源未找到。

### 创建机器友好、可描述的结果

一个具有表现力的REST API应用谨慎的考虑返回的结果。由于API的调用一般是使用软件而不是用户，因此，需要与注意调用者的交流尽可能的有效和高效。

例如，比较常见的实践，当我们使用200返回码来HTML解释错误信息。虽然，技术上没有什么问题，用户可以看到错误的页面信息，但是对于机器来说，会认为这次请求成功了。

HTTP状态码应该是有用的并且有相关性的。当操作正常时使用200（OK）。当没有内容返回时，使用204（NO CONTENT）。201（CREATED）应该用于POST请求，表明创建资源的结果，无论是否有响应体。当并发更新冲突时使用409（CONFLICT），当请求参数类型不正确时使用400（BAD REQUEST）。

### 资源URI和版本

RESTful 资源 URI有很多可选的地方。一般而言，资源应该以名词进行描述，而不是动词，节点应该以复数的形式表示。例如：


| URI  | 说明  |
| --- | --- |
| POST /accounts | Create a new item |
| GET /accounts   | Retrieve a list of items |
| GET /accounts/16 | Retrieve a specific item |
| PUT /accounts/16 | Update a specific item |
| PATCH /accounts/16 | Update a specific item |
| DELETE /accounts/16 | Delete a specific item |

URI可以是层级嵌套的方式组织

**版本控制**

微服务最大的好处是，每个服务都可以独立开发演进。服务之间的调用保持独立的前提是，这些API不能轻易更改。

稳健性原则，服务作为发送方要保守一些，作为接收方可以随意一些，在API改变之前一直要保持这种原则。当仍然需要修改API时，可以选择构建一个不同的整个服务，并逐渐替换原始的服务，也许领域模型的演进和更好的抽象能让这件事情更有意义。

如果不需要改变现有的API服务，那么如何管理这些改变呢：
- 服务是否处理所有版本的API？
- 是否需要维护服务的版本来支持多个版本的API？
- 服务是否只支持最新版的API，并且依赖其他的适配层来转换和来自旧版的API？

我们很难抉择，最本质的问题是，我们如何映射API的版本。这有三种方式来处理REST资源的版本：
- 在URI中设置版本
- 使用自定义的版本请求头
- 将版本设置在HTTP的Accept请求头，并依赖内容协调

**URI中添加版本信息** 
这种是最简单的方法来指定版本，有以下几个优点：
- 容易理解
- 容易实现
- 容易使用API浏览工具（例如 Swagger） 和 命令行工具（例如 curl）

如果决定采用URI中版本进行控制，那么版本号需要设置到整个应用上，例如 `api/v1/accounts` ，而不是`api/accounts/v1` .

如果决定使用URI中版本，我们可以采用不同的方式进行管理，部分取决于请求在系统中如何路由。

当然也有反对这种版本控制方式，URL是HTML标准中一个严格解释的，一条URL应该代表一个实体并且如果实体不改变，那么URL也不改变。

其他也指出，将版本放到URI中需要消费者更新他们的URI引用。这种问题可以通过将旧版URI映射到新的请求中，然而，当最新的版本改变时，这样的方法会出现异常行为。

**添加自定义的请求头**

我们也可以添加自定义的请求头来指明API的版本。自定义的请求头可以被路由器或其他基础设施来路由到特定的后台实例。然而，这种机制不容易使用。此外，这种自定义的头只能在我们自己的应用中使用，也就是消费者需要学习如何使用。

**修改Accept Header添加版本**

Accept Header是一个比较明显的地方用于定义版本，但是很难测试。URIs 很容易指定并替换，但是指定HTTPHeader需要更多API的信息以及命令行调用。

设计API时，有以下几点建议：
1.从消费者的角度设计APIs
2.考虑API改变的策略
3.在整个应用中使用一致的版本控制技术

# 3 服务注册与发现

微服务被设计成能够容易水平扩展，需要一种方法来解决多个服务实例如何定位，并且对多个服务的调用如何负载均衡。服务定位包括以下三个部分内容：
1.服务注册
2.服务调用
3.API网关

## 服务注册

服务注册是一个持久化的存储，用于记录当前可用的微服务列表，以及访问他们的路由信息。微服务之间通信需要注册服务，主要因为以下几个原因：
1.注册
当一个服务成功的部署后，微服务需要通过服务注册进行注册
2.心跳
微服务应该发送规律的心跳信息，到注册中心，用于表明当前微服务是正常工作，可以接受请求。
3.服务发现
为了调用其他服务，微服务需要调用注册中心获取可用的服务实例
4.注销
当一个服务关闭后，需要从注册列表中移除该服务。

### 第三方注册 VS 自注册

注册微服务可以在服务中实现也可以使用第三方注册服务。使用第三方注册服务，要求微服务准确测定当前状态并将信息传给注册服务。第三方注册服务也可以注销微服务。如果微服务自己执行注册和心跳检测，注册服务可以取消注册，如果发现心跳丢失。

使用第三方注册服务的优势是，可以将注册和心跳检测的逻辑与业务逻辑分离。缺点是软件需要部署额外的部分，微服务也需要提供健康端点给第三方注册服务使用。

自注册（self-registration）将注册和心跳检测逻辑写入到微服务自身中，这种方式需要小心处理代码测试。然而，很多服务注册解决方案提供一种方便的库用于服务注册，来降低编码的复杂度。

服务发现与注册方案

Consul

Eureka

这些都是开源的服务注册工具，Eureka是Netfli公司的技术，能很容易和其他解决方案进行集成，并且提供负载均衡和容错。


### 可用性 vs 一致性

大部分服务注册中心提供分区容忍，一致性或可用性。他们不可能同时满足CAP理论中三个条件。Eureka提供可用性，Consul和Apache Zookeeper提供一致性。如果我们应用需要在某一个能看到相同的视图，那么选用一致性的服务注册方案；如果需要很快的获得请求的答复，而不需要等待结果的一致性，可以选用可用性的方案。

## 服务调用

当服务需要与其他服务进行通信时，它需要使用存储到服务注册中心的信息。然后，通过服务端或客户端调用实际的微服务。

### 服务端

通过服务代理实现服务端通信，Service Proxy作为服务注册中心的一部分，或者独立的服务。当服务需要调用其他服务时，首先调用代理服务端点。这个代理服务会返回从服务注册中心获取的目标服务的地址。代理器将获取的结果和路由返回给原服务，提供给原服务用于发起请求。负载均衡完全在服务端处理。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180516410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

使用Server-side调用有以下几个优势：
1.请求简单
请求会很简单，因为微服务调用一个已知的终端。
2.容易测试
使用服务代理将负载均衡或路由逻辑从微服务中剥离，这样可以使用Mocked代理测试服务的所有功能。

然而，这种方式也存在缺陷

1.路由跳转过多
新增的服务代理，增加了网络请求的次数。这方式比客户端方案需要调用的次数更多。而用代理服务次缓存请求是没有价值的，很多情景，请求会走1->4->5->6

### 客户端（Client side）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180538417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)


微服务之间的调用也可以直接使用客户端调用。服务注册返回微服务一个或多个实例的地址；然后，由客户端向该地址发出请求。微服务的地址通常会被缓存起来，这样在后续的调用中可以直接访问实际的地址，而不需要向注册服务查询。如果直接访问实际地址失败，客户端将重复第一次操作，向注册服务获取信息。最好对服务地址的缓存设置超时，这样当新版的服务部署后，其他服务不会访问缓存中错误的地址，而访问新的实例。

发起这些请求，以及负载均衡可以使用以下两种方式实现：
1.客户端库（Client library）
2.边车（sidecar）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190427180550360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

两种方式都可以在客户端发起请求。然而，客户端库与微服务是一个整体，一起运行的；而边车（sidecar）是与微服务部署在一起的，可以运行在独立的进程。

**client library**
客户端库的方式很有效，将与其他远程资源通信的逻辑独立开。对于服务注册中心，client libraris可以是 Consul 或 Netflix Eureka 用于处理服务注册和心跳检测。其他的库，例如Netflix Ribbon，提供客户端的负载均衡。

一般而言，选用一个现有的库而不是自己写。如果所有的微服务使用Java编写，那边我们需要标准化这个库。如果我们有一个微服务系统，最好每个微服务使用相同的库进行请求调用，这样开发者从一个服务向另一个服务过渡不会增加基础设施和构建进程的复杂性。

这种方式的弊端是，我们将复杂的服务调用融入到了服务中，这样测试服务会变得很复杂，需要很好的区分使用了client library的代码和业务逻辑代码。

**sidecar**
另个比较好的方案是使用边车模式，边车是一个与微服务部署在一起的分离进程，或者一个分离的容器进程，或相关联的分离的容器。

边车调用服务注册中心获取服务注册信息，并保存这些信息，也具有客户端的负载均衡能力，来调用其他服务。

由于边车运行在自己的进程中，他可以使用独立的语言开发。在所有微服务中可以使用相同边车实现，而不需要管微服务使用何种语言。

[Netflix Prana](http://github.com/Netflix/Prana)是一个开源的边车组件用于提供Ribbon和Eureka客户端的能力。

[Kubernates](http://kubernetes.io/docs/user-guide/services)是一个容器编排引擎，提供服务发现和负载均衡能力的sidecar。


## API网关

API 网关（API Gateway）能够执行内部或外部客户端的服务的调用。API Gateway与服务代理的角色很像。服务向API网关发送请求，而服务网关向服务注册中心获取服务地址，然后根据地址发起请求，将请求后的结果返回给调用者。与代理服务器不同的是，API网关可以提供不同与原微服务提供的API。

内部的微服务可以使用确切的APIs，同时API网关提供外部客户端调用。一般来说，微服务提供细粒度的APIs，而外部客户端通常不需要那么细粒度的API，这时API网关可以屏蔽内部一些API，向外部客户端提供有用的API。所有的外部客户端通过API网关访问应用。

# 4 微服务间通信

在分布式系统中，服务内部的通信很重要的。组成应用的微服务需要一起无缝的工作，向客户端提供服务。不同服务之间的通信有两种形式，同步和异步调用。

## 4.1 同步和异步

同步通信，即请求后立马获得响应。异步通信，是一种消息，不需要响应。

高度分布式系统中使用异步事件或消息就是强有力的应用场景。

对于任何一种调用风格，开放的API需要提供文档说明。事件或消息负载也需要提供文档说明。事件订阅者或API消费者应该容忍不识别的字段，它们可能是新的。服务应该抛出异常和处理错误数据。

### 同步信息（REST）

在分布式系统中，异步形式的消息是很有价值的。当应用清晰的请求和响应语义，或一个服务需要与另一个服务紧密关联行为，应该使用异步API。

很多RESTful 操作能解析JSON格式的数据，当让其他协议或格式的数据也可以。基于Java的微服务最好使用JSON数据格式。



### 异步信息（Event）

异步消息能够解耦服务。一个异步事件能够使用，如果事件创造者不需要响应信息。

一个来自外部客户端的请求在获取响应信息前可能会穿过多个微服务。如果每个调用都是同步的，那么整个时间会阻断其他请求。微服务系统越复杂，那么微服务之间的交互需要额外的请求，将导致系统延时更长。如果请求的进程可以被异步事件替代，那么可以用事件来取代。

使用响应式的事件，一个服务应该发布自己状态或活动的事件。其他服务可以订阅这些事件并协同响应。

事件是很好的方式组建新的交互模式，而不需要引入依赖。这种使得框架具有扩展性，不需要再服务创建的时候考虑，后续可以扩展。

微服务风格的架构需要每个微服务拥有自己的数据。这意味着当请求进来时，可能有好几个服务需要更新自己的数据库。服务应该使用事件来通知数据变化，其他模块可以订阅这些事件。

为了协调应用中的消息，我们可以使用任何一个可用的消息代理方案。例如AMQP、RabbitMQ、Apache Kafka， MQTT等。

## 4.2 容错

我们选用微服务架构，一个很重要的动机是微服务架构可以创建容错和弹性伸缩的应用。现代应用被要求具有接近零的停机时间，秒级以内的响应。微服务架构中每个独立的服务必须能持续工作，即便其他的服务已经宕机。这就要就微服务应用在设计时具有容错的能力。

### 弹性可变

当使用同步请求调用其他微服务时，我们使用的是具体API，API被事先定义了输入属性，以及输出属性。微服务环境中，这种API的请求和响应数据一般采用JSON格式。现实中，我们很难保证输入和输出的属性不发生更改。基本是最佳的应用设计实践，需求也是经常改变的，这会造成属性的增加、删除或改变。为了弹性的应对这些变化，微服务的设计者需要考虑到API的消费和生成。

**APIs 消费**
作为API的消费者，我们需要校验调用API后获取的响应数据，判断它是否包含我们功能执行所需的信息。如果获取JSON格式的数据，我们需要解析JSON数据，在执行其他转换之前。当我们校验JSON或解析JSON时，我们必须做两件事情：

1.只校验请求中需要使用的变量或熟悉
不需要校验请求提供的所有变量。如果我们使用这些请求中的参数，我们不需要它们。
2.接受未知的属性
不需要提交异常，如果我们接收到异常的变量。如果响应体共包含我们所需的信息，那么不用在意其他额外的属性。

选择JSON解析工具允许我们配置如何解析进来的数据。例如Jackson提供@JsonInclude和@JsonIgnoreProperties注解的方式解析数据。

遵从这两天规则，我们的微服务可以变得更加弹性来应对任何改变，而不会受到直接影响。基本微服务添加或移除我们并未使用的属性，微服务仍然正常工作。

**APIs 生成**

当提供外部客户端调用的API时，请求和响应中有两件事需要考虑：
1.接收未知的请求属性
如果一个服务调用API，请求中包括不需要的参数，那么服务可以丢弃这些参数值。只有引起不需要的失败时才返回错误信息。
2.只返回API调用相关的属性
留尽可能多的空间来实现服务后续的改变。避免分享的过程中泄露实现细节。

遵从这两条可以让服务更加稳健。


### 超时（Timeouts）

当请求其他微服务时，无论同步请求或异步请求，请求必须设置超时参数。因为，我们希望用完服务就走，而不应该等待不确定的响应。

异步请求可以设置超时参数，例如 Failsafe和 Netflix Hystrix内置了超时设置。

设置超时可以提升微服务的弹性，但是仍然会导致不好的用户体验，因为端到端的调用会变慢。如果可以的话将超时设置一致，那么服务A向服务B请求超时，同时服务B等待服务C。

### 熔断（Circuit Breakers）

使用超时保护请求，避免等待不确定的响应。然而，如果某个请求经常发生超时，这会浪费很多时间等待超时发生。

熔断（Circuit Breaker）是一种用来避免重复超时发生的技术。这种技术类似电路里面的保险丝。熔断会记录每个调用失败或超时的请求。如果这些请求次数总和达到了一定的阈值，它会阻断后续请求的调用，直接返回错误信息。它也提供一种机制来重新尝试请求，尝试几次或根据响应某个事件。

熔断对于调用外界服务至关重要，一般来说，使用现在的熔断库即可实现此功能。

### 隔板（Bulkheads）

在轮船中，隔板用来隔离船舱避免因一个船舱漏水造成整个船沉掉。微服务中的隔板（Bulkheads）类似轮船中的隔板概念。我们需要避免微服务中某个部分的失败不会对整个微服务系统造成影响。隔板模式就是关于如何创建微服务而不是使用某个特定工具或库。当我们创建微服务时，我们总是告诫自己如何分离不同的模块，并且避免滚雪球式的崩溃。

实现隔板模式最简单的方式是提供回退（fallbacks）。添加fallback运行应用继续工作，当非重重要的服务宕机时。例如，一个在线的零售店系统，其中一个服务提供用户推荐信息，如果推荐服务宕机了，那么用户仍然可以查询商品和下单。一个有趣的回退链例子，当调用个性内容失败时，回退成调用更加一般的内容，这将回退成返回缓存内容，而不是返回错误。

另一种策略，为了避免慢的或勉强的远程资源造成整个系统宕机，可以使用受限可用的资源来应对这些超出的请求，最常见的方式使用队列（queue），以及 [信号量（semaphore）](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html) 

**队列**
队列有一个大小设置，当请求添加到已满的队列时，该请求会直接抛错。队列会生成有限数量的worker，每个定义了服务最大的线程数，可以被远程资源阻塞。

**信号量（semaphore）**
semaphore机制工作原理，是提供多个permits，向远端发起请求是需要一个permit，当请求完成后会释放permit。

队列和信号量最显著的区别是在资源用尽时的处理不同，使用Semaphore方法，超出的请求会直接被跳过，如果不能获取到permit； 而队列的方式，请求会等待（除非队列满了，请求会被丢弃）。



# 5 数据处理


## 5.1 微服务中数据特征

定义微服务中的存储数据有一种方法，即从上到下方法。有业务级开始设计数据模型。如何定义数据、如何处理数据、如何与其他微服务的数据存储进行共享。

### 领域驱动设计实体

根据领域驱动设计，我们将会有以下几类对象：
1. 实体 Entity
    一个不是由它的属性进行定义的对象，而是根据线程定义的。
2. Value Object
    一个对象包含属性，但是没有概念的定义，可以被认为是不可变的。
3. 集合 Aggregate
    一个对象的集合，由一个根entity所组织，根节点确保变化的 一致性，避免外部对象需要引用其成员。
4. 仓库 Repository
    检索领域对象的方法应该委托给Repository对象，这样便于更换具体的存储实现的方法。


这些对象映射到我们的持久存储。领域模型（domain model）是逻辑数据模型和物理数据模型的基础。

参考：http://dddcommunity.org/resources/ddd_terms/

### 分离每个微服务的数据存储

每个微服务应该有自己的数据存储，这样可以与其他服务进行解耦，如下图所示。第二个服务不能直接访问第一个服务的存储层。

这样设计有以下几个理由：
1. 如果两个微服务共享数据存储，他们将紧密耦合。改变一个微服务的数据结构，例如table，可能影响另一个微服务。如果微服务这种方式耦合，那么部署新版需要花费时间进行协调，而这是可以避免的。
2.每个微服务应该使用最有利该服务功能的数据类型。我们不需要权衡不同服务如何选择数据库系统。每个微服务使用最合适的数据库。
3.从性能的角度考虑，每个微服务拥有自己的数据存储，这样扩展就会很容易。数据存储可以拥有自己的服务器。

对于关系型数据库的数据存储分离可以采用以下几种方式：
1.每个微服务一个Schema
    每个微服务拥有自己的schema。其他微服务可以使用相同的数据库，但是使用不同的schema。可以通过数据库访问控制机制进行约束，避免开发者直接访问其他schema。
2.每个微服务一个Database
    每个微服务可以拥有自己的数据库，但是与其他微服务共享数据库服务器。不同的数据库，用户可以连接到各自的数据库，这是一种很好的分离方式。
3.每个微服务一个数据库服务器
    最高度的分离，即每个微服务拥有独自的数据库服务器。当需要更高的性能时，可以采用这种方式。
    
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214609705.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)
### 混合持久化（Polyglot Persistence）

每个微服务应该有自己的数据存储，这意味着可以使用不同的数据存储技术。NoSQL运动导致很多新的数据存储技术产生，NoSQL可以和传统关系型数据库一起使用。根据应用需求，可以选用不同的数据存储类型来实现。在一个应用中使用多种数据存储技术，称为混合持久化。
 
对于某些微服务，最好用关系型数据库存储数据。其他服务，如果使用到不同的数据类型（非结构、复杂、有向图）等数据可以存储在NoSQL数据库。


https://martinfowler.com/bliki/PolyglotPersistence.html

### 跨微服务数据共享

某些情景下，一个微服务的客户端可能请求另一个微服务的数据。例如，一个客户端可能需要查看他的账单和以及账单状态。然后，他可能需要查询他的账户，然后到账单服务。微服务最佳实践避免将数据存在同一个数据库中。为了解决上述这个业务场景，我们可以实现一个适配服务，用于查询Account服务和Payment服务，然后将查询结果发给客户端。适配器服务也负责处理接收数据的转换，如果有需要的话。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214637724.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

改变数据会变得很复杂。在一个微服务系统中，某些业务事务横跨多个微服务。在一个零售店应用的微服务示例中，可能有一个服务用于下单，一个服务由于付款。因此，如果一个消费者用户想购买商店的某个东西时，这个业务事务可能在这两个服务中扭转。每个微服务有自己的数据存储，因此业务事务可能横跨两个或多个微服务，将调用多个数据存储。如何应对这种业务事务呢？


**Event-Driven 架构**

在调用涉及多个微服务的业务事务时，我们需要确保数据的一致性。可以采用分布式事务，但是有很多理由表明不应该在微服务应用中使用。主要的原因是会让微服务变得过于耦合。如果两个微服务在一个分布式事务中调用，那么其中一个错处或有性能问题，那么另一个服务也会等待直到超时发生，回滚事务。

使用事件驱动架构（Event-Driven architecture）是最好的方式来解决横跨多个微服务的业务事务。为了改变数据，第一个服务更新数据，在同一个事务中，发布一个事件。第二个微服务，订阅这个事件，当接收到这个事件时，也改变自己的数据。使用发布/订阅（publish/subscribe）通信模型，可以让两个微服务松耦合。这个耦合只存在于交互的消息中。这个技术使得微服务系统可以维护多个微服务的数据一致性，而不需要使用分布式事务。

如果微服务应用中，微服务之间发送很多消息，最好可以将这些服务合并成一个服务。但是这样可能会违背领域驱动设计的原则。横跨多个微服务的适配服务负责复杂的数据更新，可以采用事件的方式实现。

**最终一致性 （Eventual Consistency）**

在事件驱动的架构中，发送消息可能产生最终一致性的问题。这是君臣发生的运行时问题：服务A改变自己的数据，并发送消息到服务B，经过很短的一段时间后，服务B接收到消息，并改变自己的数据。在这个很短的接收时间里，两个服务的数据是不一致的。例如，服务A更新了订单数据，并发送消息到付款服务B，直到服务B处理完付款，有一个订单已经被付款了。当消息的接收者不能处理这个消息时会发生错误。在这个情况下，消息系统或接收消息的微服务需要解决这个问题。

由于微服务框架中每个服务拥有自己的数据库，横跨多个服务的业务事务会引入最终一致的问题。如下图所示的，可以解决这个问题。订单服务保存订单，发送操作事件。例如 OrderCreated事件 发送到Payment服务，当订单服务没有接收到Payment服务的确认消息前，订单服务处于等待状态。

付款服务（Payment）订阅OrderCreated事件，接收后处理这个事件，并在数据存储中处理付款。如果付款成功，那么将发布PaymentApproval事件，这个事件被订单服务（Order）订阅。当处理完PaymentApproval事件后，订单的状态会从等待变为批准。如果消费者查询订单的状态，他将获得两种状态中的一种：订单等待或订单完成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429214715470.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

在这种情境下，当数据不可用时，服务可以发送“对不起，请稍后重试”的消息到客户端。

**数据备份**

数据库系统的数据备份机制可以解决，因数据存储分离造成的数据获取问题。使用数据备份，例如，使用数据库触发器或时序的存储过程或其他进程，多个服务之间共享数据同样存在缺陷。改变一方的数据结构，将会导致备份进程的问题。这个备份机制必须能适应后续新增的服务部署。这也是一种紧耦合的形式，需要避免。

综上所述，事件驱动可以解耦两个数据存储。服务可以处理自己数据中这些事件有关的数据转换。



### Event Sourcing 和CQRS（Command Query Responsibility Segregation）

在事件驱动架构中，Command Query Responsibility Segregation 和 Event Sourcing， 这两种架构模式可以结合起来解决微服务应用中的事件流。

CQRS 将数据存储分离成两个独立的部分：一部分用于读取操作，另一部分用于写操作。度操作不会改变系统的状态，只获取系统状态。写操作会改变系统的状态，但是不会返回数值。

Event Sourcing 存储一系列的事件，这些事件发生在数据改变时。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190429215250822.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

如上图所示，事件按顺序存储在Event stores中，数据查询模型中的数据与事件存储中的数据同步。为了让事件存储或查询模型，我们可以使用一些系统，例如 Elastic Search 来支持微服务中的查询。

这种架构可以用于处理微服务应用中的事件。

### 消息系统

我们可以使用消息系统或面向消息的中间件来支持事件驱动架构。

面向消息的中间件（MOM，Message-oriented Middleware），是一个软件或硬件基础设施，用于分布式系统之间发送和接收消息。MOM使得异构的应用模块分离，并降低跨多系统和网络应用开发的复杂度。中间件可以创建分布式通信层，避免开发者考虑操作系统和网络接口的细节。跨多种平台和网络的扩展，由MOM的API提供。MOM提供客户端/服务器架构模式的软件通信所需的组件，也支持异步调用。MOM减少应用开发者投入复杂的主从的客户端/服务器机制的原理。

与MOM通信可以使用不同的协议，例如
1. AMQP（Advanced Message Queuing Protocol）
    授权管理消息提供者和客户端的行为，可以实现多个对象之间的互操作。类似SMTP、HTTP、FTP。具体实现有：RabbitMQ、Apache Qpid、Red Hat Enterprise MRG
2. MQTT (MQ Telemetry Transport）
    MQTT是一种 发布/订阅模式，轻量级的消息协议，基于TCP/IP协议之上的。设计用于远程定位连接，带宽限制的和小编码的场景。更多在物联网IoT中使用。



### 分布式事务

大部分但不是全部的消息系统支持事务。当我们需要发送消息到消息系统，事务中改变数据时，也可以使用分布式事务。

分布式事务、两段提交（Two-phase commit）可以用于一个微服务，以及它的后端存储，但是不能在微服务之间使用。本质上要保持微服务的独立，因此具体的服务实例之间不应该存在密切的关系，例如两个服务之间需要两段提交。

对于跨服务的交互，事务补偿或和解逻辑应该添加以确保一致性。



# 6 应用安全

安全作为应用重要部分，必须要考虑。本章讨论在云原生的微服务架构下的安全要求。

## 6.1 微服务架构安全

微服务架构动态的本质，改变了安全的方式。安全与如何定义应用或服务边界相关。如下图所示，表示单块应用和微服务应用的请求流程图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430165652418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkcDEyMzE1,size_16,color_FFFFFF,t_70)

单块应用和微服务应用两者最大的区别，单块应用的组成是固定的，而微服务的组成经常发生变化。微服务独立更新。安全边界永远不够。如何以一种有机的方式保护这种快速变化的基础设施，级每个独立的服务可以自由改变和演进，而不需要中央协调。


### 网络分离

在上图中，两种风格的系统中都有一个分离的子网络，使用外部的防火墙或网关保护资源是一种比较好的方法。

如上图所示，外部API连接了两个不同的微服务应用，需要定义合理的应用边界，来分割多个独立的系统，这是一种很好的方式来保护动态的系统环境。

在主机环境网络分离很自然，例如微服务应用，如上图所示，每个微服务可以看做多租户（multi-tenant）环境中的一个租户。一般不会发生这种，除非需要这样。然而，微服务架构中管理网络的最佳实践是将外部管好。

### 确保数据隐私

不同类型的数据需要不同层级的保护，这些保护会影响数据的访问、传输、存储。

当需要处理数据时，可以考虑以下内容：
1.不要传输原始文本的密码
2.保护私钥
3.使用知名的加密技术，而非自定义
4.使用加盐的hash来存储密码，https://crackstation.net/hashing-security.htm
5.敏感的数据应该尽早被加密，尽可能晚的解密。如果敏感数据需要在服务之间流转，保持加密形式，除非需要需要用到这个数据。这可以避免意外泄露。

**backing service**
连接后端服务，作为网络中添加的资源，需要被保护起来。在很多云环境中，后端服务由云平台提供，依赖于多租户（multi-tenancy）和API keys，或访问令牌（access tokens）提供数据隔离。理解后端的这些特性至关重要，特别是它如何存储数据，确保满足监管要求（HIPAA， PCI等）。

**Log data**

日志数据需要权衡哪些用来进行问题诊断，哪些必须保护起来，出于监管和隐私原因。当输出日志时，充分利用日志的等级来控制数据如何输出。对于用户提供的数据，需要考虑这些数据是否原本属于日志内容。例如，我们是否需要将这个属性的值写入日志中，或我们是否真的关系它是否为null。

### 自动化

尽可能的让微服务自动化，包含一般的运维。可重复的自动进程应该应用于跨分片环境下申请安全策略、证书、管理SSL证书以及钥匙，避免人为错误。

信用证、证书、钥匙应该存储到一个地方，以供自动化使用，可以考虑以下建议：
1.不要将证书存在应用中
2.不要将证书存储在公共仓库中
3.只存储加密的数据




## 6.2 标识和信任

在高度分布的、动态的环境下，例如微服务架构，在建立稳定统一模式的标识上花费很大功夫。我们必须建立和维护用户的标识，而不会调用中心服务，从而引入额外的延迟或内容。

在这个环境中建立和维护可信不是那么容易，假设私有网络是安全的这种方式本身就是不安全的。端到端的SSL可以加密传输的字节，但是它不能只考自己构建一个可信的环境，它key管理方。

 本节讨论认证与授权，以及标识传播，用于建立和维护可信任的服务间通信。

### 认证与授权

微服务环境中需要认证和授权，在单块应用中，拥有细粒度的角色、角色与中心用户仓库相关联。微服务独立生命周期的重要性，像这种角色和用户的依赖是反面模式（anti-pattern）。开发独立的微服务受中心资源更新的约束。

专注的、中心化的服务或API网关创建认证（authentication，建立用户标识信息）是很常见的做法。这个中心的服务可以将用户认证信息代理给第三方。

当使用授权（auhorization，建立用户的权限，访问受保护资源权限的权限），在微服务环境中，保持组或角色的定义粗粒度是很常见的做法，跨服务切片。允许独立服务维护自己的控制粒度。将服务确保独立为基本原则。根据应用整体需求，权衡哪些在公共授权服务中定义，哪些在特定的服务中实现。


### 授权委托 OAuth2.0

OAuth 提供一个开源的框架，用于授权第三方应用访问。虽然框架定义了授权的交互模式，但是没有定义程序接口。具体参考：https://tools.ietf.org/html/rfc6749

OpenID Connect（OIDC）提供了一个基于OAuth2.0的表示层，委托认证至第三方。它定义了一个基于REST的互操作机制，建立在OAuth之上。具体可参考：https://openid.net/connect/

### JWT （Json web tokens）

标识传递是微服务架构中另一个具有挑战性的问题，当用户（human或 服务）已经认证后，表示需要以一种可信的方式传递到另一个服务。频繁的调用认证中心来校验表示是非常低效的，特别是通过中心网关路由的服务与服务之间的通信，会产生延迟。

JWT 可以携带用户的信息，可以完成以下任务：
1.知道用户的请求由用户初始化
2.知道请求的表示由谁产生
3.知道这个请求不是由前一个请求恶意重复的

JWT有契约的和URL友好的。从名称中也可以猜出，JWT包含一种JSON结构的数据。这个结构包含标准的申明属性，例如提交者、目标，过期时间。清晰的映射其他安全机制。JWT也提供自定义的空间，允许添加额外信息。

当我们构建应用的同时，我们很可能被告诫，JWT因为显示性而无效。对于安全和隐私原因，登录时将准确的错误信息告诉前端是一种不好的主意。这样做可能泄露具体的实现或用户细节。JWT.IO 提供很多有用的web工具，帮助开发JWT应用，具体参考：https://jwt.io

**处理时间**

JWT有一个优点是确定性地运行标识传递。当JWT过期，会触发校验JWT中的标识，从而产生新的JWT。JWT有三个字段与时间相关，都是可选的。一般来说，包括以下字段：
1.JWT创建时间（iat），在当前时间之前表示有效
2.“no process before”（nbf），在当前时间之前表示有效
3.过期时间（exp），在当前时间之后表示，jwt有效

这些时间都是以UNIX时间戳表示。

**Signed JWT**

签名JWT能在服务之间够建立信任，一个接收者可以校验签名者的表示，以及JWT的内容是否被更改过。

JWT可以使用共享的秘钥进行签名，或者秘钥对（public/private, SSL 证书）。

### 基于Hash的消息认证编码

使用基于Hash的消息认证码（HMAC，Hash-based Messaging Authentication Code）进行认证比HTTP basic优雅。当使用HMAC，请求信息被哈希编码并签名，用于创建一个署名，然后，包含在发送的请求中。当请求被接收，这个请求属性将被反哈希，用于确保数值是匹配的。这中方式可以认证用户，校验内容在传输中没有被修改。这种哈希标签可以疲惫重复的攻击。

HMAC校验能在API网关中使用。例如，网关认证用户，然后无论服务缓存响应信息、生成JWT或者其他自定义的头。使用JWT的好处是运行下游的服务一致地使用JWT来识别用户，将原来认证方法进行解耦独立。

HMAC不是完整的标准，API提供（网关或独立的服务）方经常需要提供不同的请求参数来生成签名。

建议使用HMAC共享库，因为HMAC需要在API消费者和提供方进行计算。

### API Keys 和共享秘钥

一个API key可以代表不同的含义，但一般用来识别原始请求。识别原始的请求在API管理中非常重要，比如 限流或跟踪。API Keys通常与账户的证书分开，根据需要创建或销毁。

一个API Key可以是一串字符，但是不像密码，这个字符串是随机生成的，超过40个字符长度。然而，优势字符直接在请求中使用，作为bearer token 或查询参数。使用API key可以让共享秘钥的签名的JWT更安全，或者数字方法（HMAC）。

如果服务创建API key，确保API key是以高度加密和正确存储的安全方式生成的。确保这些key能随时吊销。如果应用有分离的部分，那么为每个部分应该使用不同的API key。这样便于更细粒度的用户使用追踪，减少某个危险key造成的影响。

也可以使用非对称秘钥（例如 SSL），但是需要维护一个公钥基础设施（public key infrastructure，PKI）。虽然这样更安全，但是可以加大人力劳动，并且也很难管理，如果第三方也是API消费者。

考虑到12要素，秘钥应该依据配置注入，当微服务内部通讯时。这个secret不应该硬编码到应用中，因为这样会造成危险。











